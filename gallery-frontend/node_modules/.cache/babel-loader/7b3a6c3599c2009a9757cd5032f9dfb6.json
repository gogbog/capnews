{"ast":null,"code":"// src/utils/CryptoUtils.ts\nimport CryptoJS from \"crypto-js/core.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport Base64 from \"crypto-js/enc-base64.js\";\nimport Utf8 from \"crypto-js/enc-utf8.js\"; // src/utils/Logger.ts\n\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\n\nvar Log = /* @__PURE__ */(Log2 => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n\n(Log2 => {\n  function reset() {\n    level = 3\n    /* INFO */\n    ;\n    logger = nopLogger;\n  }\n\n  Log2.reset = reset;\n\n  function setLevel(value) {\n    if (!(0\n    /* NONE */\n    <= value && value <= 4\n    /* DEBUG */\n    )) {\n      throw new Error(\"Invalid log level\");\n    }\n\n    level = value;\n  }\n\n  Log2.setLevel = setLevel;\n\n  function setLogger(value) {\n    logger = value;\n  }\n\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\n\nvar Logger = class {\n  constructor(_name) {\n    this._name = _name;\n  }\n\n  debug() {\n    if (level >= 4\n    /* DEBUG */\n    ) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      logger.debug(Logger._format(this._name, this._method), ...args);\n    }\n  }\n\n  info() {\n    if (level >= 3\n    /* INFO */\n    ) {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      logger.info(Logger._format(this._name, this._method), ...args);\n    }\n  }\n\n  warn() {\n    if (level >= 2\n    /* WARN */\n    ) {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      logger.warn(Logger._format(this._name, this._method), ...args);\n    }\n  }\n\n  error() {\n    if (level >= 1\n    /* ERROR */\n    ) {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      logger.error(Logger._format(this._name, this._method), ...args);\n    }\n  }\n\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n\n  static createStatic(name, staticMethod) {\n    const staticLogger = new Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  } // helpers for static class methods\n\n\n  static debug(name) {\n    if (level >= 4\n    /* DEBUG */\n    ) {\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      logger.debug(Logger._format(name), ...args);\n    }\n  }\n\n  static info(name) {\n    if (level >= 3\n    /* INFO */\n    ) {\n      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        args[_key6 - 1] = arguments[_key6];\n      }\n\n      logger.info(Logger._format(name), ...args);\n    }\n  }\n\n  static warn(name) {\n    if (level >= 2\n    /* WARN */\n    ) {\n      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n\n      logger.warn(Logger._format(name), ...args);\n    }\n  }\n\n  static error(name) {\n    if (level >= 1\n    /* ERROR */\n    ) {\n      for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        args[_key8 - 1] = arguments[_key8];\n      }\n\n      logger.error(Logger._format(name), ...args);\n    }\n  }\n\n};\nLog.reset(); // src/utils/CryptoUtils.ts\n\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar CryptoUtils = class {\n  static _randomWord() {\n    return CryptoJS.lib.WordArray.random(1).words[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n\n\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16));\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n\n\n  static generateCodeVerifier() {\n    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n\n\n  static generateCodeChallenge(code_verifier) {\n    try {\n      const hashed = sha256(code_verifier);\n      return Base64.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n\n\n  static generateBasicAuth(client_id, client_secret) {\n    const basicAuth = Utf8.parse([client_id, client_secret].join(\":\"));\n    return Base64.stringify(basicAuth);\n  }\n\n}; // src/utils/Event.ts\n\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._logger = new Logger(`Event('${this._name}')`);\n    this._callbacks = [];\n  }\n\n  addHandler(cb) {\n    this._callbacks.push(cb);\n\n    return () => this.removeHandler(cb);\n  }\n\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n\n  raise() {\n    for (var _len9 = arguments.length, ev = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      ev[_key9] = arguments[_key9];\n    }\n\n    this._logger.debug(\"raise:\", ...ev);\n\n    for (const cb of this._callbacks) {\n      void cb(...ev);\n    }\n  }\n\n}; // src/utils/JwtUtils.ts\n\nimport jwt_decode from \"jwt-decode\";\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return jwt_decode(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n\n}; // src/utils/PopupUtils.ts\n\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center(_ref) {\n    let { ...features\n    } = _ref;\n\n    var _a, _b, _c;\n\n    if (features.width == null) features.width = (_a = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null) (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n\n  static serialize(features) {\n    return Object.entries(features).filter(_ref2 => {\n      let [, value] = _ref2;\n      return value != null;\n    }).map(_ref3 => {\n      let [key, value] = _ref3;\n      return `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`;\n    }).join(\",\");\n  }\n\n}; // src/utils/Timer.ts\n\nvar Timer = class extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n\n    this._callback = () => {\n      const diff = this._expiration - Timer.getEpochTime();\n\n      this._logger.debug(\"timer completes in\", diff);\n\n      if (this._expiration <= Timer.getEpochTime()) {\n        this.cancel();\n        super.raise();\n      }\n    };\n  } // get the time\n\n\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = Timer.getEpochTime() + durationInSeconds;\n\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n\n  get expiration() {\n    return this._expiration;\n  }\n\n  cancel() {\n    this._logger.create(\"cancel\");\n\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n\n}; // src/utils/UrlUtils.ts\n\nvar UrlUtils = class {\n  static readParams(url) {\n    let responseMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"query\";\n    if (!url) throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, window.location.origin);\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n\n}; // src/errors/ErrorResponse.ts\n\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n\n    this.name = \"ErrorResponse\";\n\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n  }\n\n}; // src/errors/ErrorTimeout.ts\n\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n\n    this.name = \"ErrorTimeout\";\n  }\n\n}; // src/AccessTokenEvents.ts\n\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n\n  load(container) {\n    const logger2 = this._logger.create(\"load\");\n\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n\n        this._expiringTimer.cancel();\n      }\n\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n\n      this._expiredTimer.cancel();\n    }\n  }\n\n  unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n\n    this._expiringTimer.cancel();\n\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n\n\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n\n\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n\n\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n\n\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n\n}; // src/CheckSessionIFrame.ts\n\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n\n    this._message = e => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n\n  load() {\n    return new Promise(resolve => {\n      this._frame.onload = () => {\n        resolve();\n      };\n\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n\n    this._logger.create(\"start\");\n\n    this.stop();\n    this._session_state = session_state;\n\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n\n  stop() {\n    this._logger.create(\"stop\");\n\n    this._session_state = null;\n\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n\n}; // src/InMemoryWebStorage.ts\n\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n\n  clear() {\n    this._logger.create(\"clear\");\n\n    this._data = {};\n  }\n\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n\n    return this._data[key];\n  }\n\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n\n    this._data[key] = value;\n  }\n\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n\n    delete this._data[key];\n  }\n\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n\n}; // src/JsonService.ts\n\nvar JsonService = class {\n  constructor() {\n    let additionalContentTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    let _jwtHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    this._jwtHandler = _jwtHandler;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n\n  async fetchWithTimeout(input) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      timeoutInSeconds,\n      ...initFetch\n    } = init;\n\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n\n    try {\n      const response = await fetch(input, { ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  async getJson(url) {\n    let {\n      token,\n      credentials\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const logger2 = this._logger.create(\"getJson\");\n\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n\n    let response;\n\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, {\n        method: \"GET\",\n        headers,\n        credentials\n      });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n\n    if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n\n    let json;\n\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok) throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n\n    return json;\n  }\n\n  async postForm(url, _ref4) {\n    let {\n      body,\n      basicAuth,\n      timeoutInSeconds,\n      initCredentials\n    } = _ref4;\n\n    const logger2 = this._logger.create(\"postForm\");\n\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n\n    let response;\n\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, {\n        method: \"POST\",\n        headers,\n        body,\n        timeoutInSeconds,\n        credentials: initCredentials\n      });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n\n    if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n\n    const responseText = await response.text();\n    let json = {};\n\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok) throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n\n    return json;\n  }\n\n}; // src/MetadataService.ts\n\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._jsonService = new JsonService([\"application/jwk-set+json\"]);\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n\n      this._signingKeys = this._settings.signingKeys;\n    }\n\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n\n      this._metadata = this._settings.metadata;\n    }\n\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, {\n      credentials: this._fetchRequestCredentials\n    });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n    return this._metadata;\n  }\n\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n\n  getTokenEndpoint() {\n    let optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n\n  getRevocationEndpoint() {\n    let optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n\n  getKeysEndpoint() {\n    let optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n\n  async _getMetadataProperty(name) {\n    let optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n\n    return metadata[name];\n  }\n\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri);\n    logger2.debug(\"got key set\", keySet);\n\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n\n}; // src/WebStorageStateStore.ts\n\nvar WebStorageStateStore = class {\n  constructor() {\n    let {\n      prefix = \"oidc.\",\n      store = localStorage\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n\n    const len = await this._store.length;\n    const keys = [];\n\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n\n    return keys;\n  }\n\n}; // src/OidcClientSettings.ts\n\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultResponseMode = \"query\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar DefaultClockSkewInSeconds = 60 * 5;\nvar OidcClientSettingsStore = class {\n  constructor(_ref5) {\n    let {\n      // metadata related\n      authority,\n      metadataUrl,\n      metadata,\n      signingKeys,\n      metadataSeed,\n      // client related\n      client_id,\n      client_secret,\n      response_type = DefaultResponseType,\n      scope = DefaultScope,\n      redirect_uri,\n      post_logout_redirect_uri,\n      client_authentication = DefaultClientAuthentication,\n      // optional protocol\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      acr_values,\n      resource,\n      response_mode = DefaultResponseMode,\n      // behavior flags\n      filterProtocolClaims = true,\n      loadUserInfo = false,\n      staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n      clockSkewInSeconds = DefaultClockSkewInSeconds,\n      userInfoJwtIssuer = \"OP\",\n      mergeClaims = false,\n      disablePKCE = false,\n      // other behavior\n      stateStore,\n      refreshTokenCredentials,\n      revokeTokenAdditionalContentTypes,\n      fetchRequestCredentials,\n      refreshTokenAllowedScope,\n      // extra query params\n      extraQueryParams = {},\n      extraTokenParams = {}\n    } = _ref5;\n    this.authority = authority;\n\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.clockSkewInSeconds = clockSkewInSeconds;\n    this.userInfoJwtIssuer = userInfoJwtIssuer;\n    this.mergeClaims = !!mergeClaims;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n    if (fetchRequestCredentials && refreshTokenCredentials) {\n      console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n    }\n\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({\n        store\n      });\n    }\n\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n  }\n\n}; // src/UserInfoService.ts\n\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n\n    this._getClaimsFromJwt = async responseText => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n\n    this._jsonService = new JsonService(void 0, this._getClaimsFromJwt);\n  }\n\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n\n}; // src/TokenClient.ts\n\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(this._settings.revokeTokenAdditionalContentTypes);\n  }\n\n  async exchangeCode(_ref6) {\n    let {\n      grant_type = \"authorization_code\",\n      redirect_uri = this._settings.redirect_uri,\n      client_id = this._settings.client_id,\n      client_secret = this._settings.client_secret,\n      ...args\n    } = _ref6;\n\n    const logger2 = this._logger.create(\"exchangeCode\");\n\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n\n    const params = new URLSearchParams({\n      grant_type,\n      redirect_uri\n    });\n\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n\n    let basicAuth;\n\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n\n        break;\n    }\n\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n\n  async exchangeCredentials(_ref7) {\n    let {\n      grant_type = \"password\",\n      client_id = this._settings.client_id,\n      client_secret = this._settings.client_secret,\n      scope = this._settings.scope,\n      ...args\n    } = _ref7;\n\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n\n    const params = new URLSearchParams({\n      grant_type,\n      scope\n    });\n\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n\n    let basicAuth;\n\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n\n        break;\n    }\n\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n\n  async exchangeRefreshToken(_ref8) {\n    let {\n      grant_type = \"refresh_token\",\n      client_id = this._settings.client_id,\n      client_secret = this._settings.client_secret,\n      timeoutInSeconds,\n      ...args\n    } = _ref8;\n\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n\n    const params = new URLSearchParams({\n      grant_type\n    });\n\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n\n    let basicAuth;\n\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n\n        break;\n    }\n\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n\n\n  async revoke(args) {\n    var _a;\n\n    const logger2 = this._logger.create(\"revoke\");\n\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n\n    params.set(\"client_id\", this._settings.client_id);\n\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n\n    await this._jsonService.postForm(url, {\n      body: params\n    });\n    logger2.debug(\"got response\");\n  }\n\n}; // src/ResponseValidator.ts\n\nvar DefaultProtocolClaims = [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\" // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n\n  async validateSigninResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n\n    this._processSigninState(response, state);\n\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state);\n    logger2.debug(\"code processed\");\n\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n\n      logger2.debug(\"ID Token validated\");\n    }\n\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n\n  _processSigninState(response, state) {\n    var _a;\n\n    const logger2 = this._logger.create(\"_processSigninState\");\n\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n\n  async _processClaims(response) {\n    let skipUserInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let validateSub = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const logger2 = this._logger.create(\"_processClaims\");\n\n    response.profile = this._filterProtocolClaims(response.profile);\n\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n\n    response.profile = this._mergeClaims(response.profile, this._filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n\n  _mergeClaims(claims1, claims2) {\n    const result = { ...claims1\n    };\n\n    for (const [claim, values] of Object.entries(claims2)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        const previousValue = result[claim];\n\n        if (!previousValue) {\n          result[claim] = value;\n        } else if (Array.isArray(previousValue)) {\n          if (!previousValue.includes(value)) {\n            previousValue.push(value);\n          }\n        } else if (result[claim] !== value) {\n          if (typeof value === \"object\" && this._settings.mergeClaims) {\n            result[claim] = this._mergeClaims(previousValue, value);\n          } else {\n            result[claim] = [previousValue, value];\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _filterProtocolClaims(claims) {\n    const result = { ...claims\n    };\n\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  async _processCode(response, state) {\n    const logger2 = this._logger.create(\"_processCode\");\n\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n\n  _validateIdTokenAttributes(response, currentToken) {\n    var _a;\n\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n\n    logger2.debug(\"decoding ID Token JWT\");\n    const profile = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n\n    if (!profile.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n\n    if (currentToken) {\n      const current = JwtUtils.decode(currentToken);\n\n      if (current.sub !== profile.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n\n      if (current.auth_time && current.auth_time !== profile.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n\n      if (current.azp && current.azp !== profile.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n\n      if (!current.azp && profile.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n\n    response.profile = profile;\n  }\n\n}; // src/State.ts\n\nvar State = class {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n\n    this.request_type = args.request_type;\n  }\n\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type\n    });\n  }\n\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return new State(JSON.parse(storageString));\n  }\n\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n\n      if (item) {\n        try {\n          const state = State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n\n}; // src/SigninState.ts\n\nvar SigninState = class extends State {\n  constructor(args) {\n    super(args);\n\n    if (args.code_verifier === true) {\n      this.code_verifier = CryptoUtils.generateCodeVerifier();\n    } else if (args.code_verifier) {\n      this.code_verifier = args.code_verifier;\n    }\n\n    if (this.code_verifier) {\n      this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n    }\n\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return new SigninState(data);\n  }\n\n}; // src/SigninRequest.ts\n\nvar SigninRequest = class {\n  constructor(_ref9) {\n    let {\n      // mandatory\n      url,\n      authority,\n      client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      // optional\n      state_data,\n      response_mode,\n      request_type,\n      client_secret,\n      nonce,\n      resource,\n      skipUserInfo,\n      extraQueryParams,\n      extraTokenParams,\n      disablePKCE,\n      ...optionalParams\n    } = _ref9;\n    this._logger = new Logger(\"SigninRequest\");\n\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n\n      throw new Error(\"url\");\n    }\n\n    if (!client_id) {\n      this._logger.error(\"ctor: No client_id passed\");\n\n      throw new Error(\"client_id\");\n    }\n\n    if (!redirect_uri) {\n      this._logger.error(\"ctor: No redirect_uri passed\");\n\n      throw new Error(\"redirect_uri\");\n    }\n\n    if (!response_type) {\n      this._logger.error(\"ctor: No response_type passed\");\n\n      throw new Error(\"response_type\");\n    }\n\n    if (!scope) {\n      this._logger.error(\"ctor: No scope passed\");\n\n      throw new Error(\"scope\");\n    }\n\n    if (!authority) {\n      this._logger.error(\"ctor: No authority passed\");\n\n      throw new Error(\"authority\");\n    }\n\n    this.state = new SigninState({\n      data: state_data,\n      request_type,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    parsedUrl.searchParams.append(\"scope\", scope);\n\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n\n    parsedUrl.searchParams.append(\"state\", this.state.id);\n\n    if (this.state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n    }\n\n    for (const [key, value] of Object.entries({\n      response_mode,\n      ...optionalParams,\n      ...extraQueryParams\n    })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n\n    this.url = parsedUrl.href;\n  }\n\n}; // src/SigninResponse.ts\n\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n\n    return this.expires_at - Timer.getEpochTime();\n  }\n\n  set expires_in(value) {\n    if (typeof value === \"string\") value = Number(value);\n\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n\n  get isOpenId() {\n    var _a;\n\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n\n}; // src/SignoutRequest.ts\n\nvar SignoutRequest = class {\n  constructor(_ref10) {\n    let {\n      url,\n      state_data,\n      id_token_hint,\n      post_logout_redirect_uri,\n      extraQueryParams,\n      request_type\n    } = _ref10;\n    this._logger = new Logger(\"SignoutRequest\");\n\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n\n      throw new Error(\"url\");\n    }\n\n    const parsedUrl = new URL(url);\n\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n      if (state_data) {\n        this.state = new State({\n          data: state_data,\n          request_type\n        });\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n      }\n    }\n\n    for (const [key, value] of Object.entries({ ...extraQueryParams\n    })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n\n    this.url = parsedUrl.href;\n  }\n\n}; // src/SignoutResponse.ts\n\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n\n}; // src/OidcClient.ts\n\nvar OidcClient = class {\n  constructor(settings) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = new OidcClientSettingsStore(settings);\n    this.metadataService = new MetadataService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n\n  async createSigninRequest(_ref11) {\n    let {\n      state,\n      request,\n      request_uri,\n      request_type,\n      id_token_hint,\n      login_hint,\n      skipUserInfo,\n      nonce,\n      response_type = this.settings.response_type,\n      scope = this.settings.scope,\n      redirect_uri = this.settings.redirect_uri,\n      prompt = this.settings.prompt,\n      display = this.settings.display,\n      max_age = this.settings.max_age,\n      ui_locales = this.settings.ui_locales,\n      acr_values = this.settings.acr_values,\n      resource = this.settings.resource,\n      response_mode = this.settings.response_mode,\n      extraQueryParams = this.settings.extraQueryParams,\n      extraTokenParams = this.settings.extraTokenParams\n    } = _ref11;\n\n    const logger2 = this._logger.create(\"createSigninRequest\");\n\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = new SigninRequest({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n\n  async readSigninResponseState(url) {\n    let removeState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n\n    const state = SigninState.fromStorageString(storedStateString);\n    return {\n      state,\n      response\n    };\n  }\n\n  async processSigninResponse(url) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n\n    const {\n      state,\n      response\n    } = await this.readSigninResponseState(url, true);\n    logger2.debug(\"received state from storage; validating response\");\n    await this._validator.validateSigninResponse(response, state);\n    return response;\n  }\n\n  async processResourceOwnerPasswordCredentials(_ref12) {\n    let {\n      username,\n      password,\n      skipUserInfo = false,\n      extraTokenParams = {}\n    } = _ref12;\n    const tokenResponse = await this._tokenClient.exchangeCredentials({\n      username,\n      password,\n      ...extraTokenParams\n    });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n\n  async useRefreshToken(_ref13) {\n    let {\n      state,\n      timeoutInSeconds\n    } = _ref13;\n\n    var _a;\n\n    const logger2 = this._logger.create(\"useRefreshToken\");\n\n    let scope;\n\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n    }\n\n    const result = await this._tokenClient.exchangeRefreshToken({\n      refresh_token: state.refresh_token,\n      // provide the (possible filtered) scope list\n      scope,\n      timeoutInSeconds\n    });\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, { ...state,\n      // overide the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n\n  async createSignoutRequest() {\n    let {\n      state,\n      id_token_hint,\n      request_type,\n      post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n      extraQueryParams = this.settings.extraQueryParams\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n\n    const url = await this.metadataService.getEndSessionEndpoint();\n\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n\n    logger2.debug(\"Received end session endpoint\", url);\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n\n    return request;\n  }\n\n  async readSignoutResponseState(url) {\n    let removeState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n\n      return {\n        state: void 0,\n        response\n      };\n    }\n\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n\n    const state = State.fromStorageString(storedStateString);\n    return {\n      state,\n      response\n    };\n  }\n\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n\n    const {\n      state,\n      response\n    } = await this.readSignoutResponseState(url, true);\n\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n\n    return response;\n  }\n\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n\n}; // src/SessionMonitor.ts\n\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n\n    this._start = async user => {\n      const session_state = user.session_state;\n\n      if (!session_state) {\n        return;\n      }\n\n      const logger2 = this._logger.create(\"_start\");\n\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        this._sid = user.profile.sid;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        this._sid = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n\n        return;\n      }\n\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n\n      this._sub = void 0;\n      this._sid = void 0;\n\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n\n          try {\n            const session = await this._userManager.querySessionStatus();\n\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub && session.sid ? {\n                  sub: session.sub,\n                  sid: session.sid\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n\n            this._checkSessionIFrame.start(session.session_state);\n\n            if (session.sid === this._sid) {\n              logger2.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n            } else {\n              logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n\n              this._userManager.events._raiseUserSessionChanged();\n            }\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n\n        if (raiseEvent) {\n          if (this._sub) {\n            this._userManager.events._raiseUserSignedOut();\n          } else {\n            this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n\n          this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n\n    this._userManager.events.addUserLoaded(this._start);\n\n    this._userManager.events.addUserUnloaded(this._stop);\n\n    this._init().catch(err => {\n      this._logger.error(err);\n    });\n  }\n\n  async _init() {\n    this._logger.create(\"_init\");\n\n    const user = await this._userManager.getUser();\n\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub && session.sid ? {\n            sub: session.sub,\n            sid: session.sid\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n\n}; // src/User.ts\n\nvar User = class {\n  constructor(args) {\n    var _a;\n\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n  }\n  /** Computed number of seconds the access token has remaining. */\n\n\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n\n    return this.expires_at - Timer.getEpochTime();\n  }\n\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n\n\n  get expired() {\n    const expires_in = this.expires_in;\n\n    if (expires_in === void 0) {\n      return void 0;\n    }\n\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n\n\n  get scopes() {\n    var _a, _b;\n\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new User(JSON.parse(storageString));\n  }\n\n}; // src/navigators/AbstractChildWindow.ts\n\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */new Set();\n    this._window = null;\n  }\n\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n\n    logger2.debug(\"setting URL in window\");\n\n    this._window.location.replace(params.url);\n\n    const {\n      url,\n      keepOpen\n    } = await new Promise((resolve, reject) => {\n      const listener = e => {\n        var _a;\n\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch (err) {\n          this._dispose();\n\n          reject(new Error(\"Invalid response from window\"));\n        }\n\n        resolve(data);\n      };\n\n      window.addEventListener(\"message\", listener, false);\n\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n\n      this._disposeHandlers.add(this._abort.addHandler(reason => {\n        this._dispose();\n\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n\n    this._dispose();\n\n    if (!keepOpen) {\n      this.close();\n    }\n\n    return {\n      url\n    };\n  }\n\n  _dispose() {\n    this._logger.create(\"_dispose\");\n\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n\n    this._disposeHandlers.clear();\n  }\n\n  static _notifyParent(parent, url) {\n    let keepOpen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let targetOrigin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window.location.origin;\n    parent.postMessage({\n      source: messageSource,\n      url,\n      keepOpen\n    }, targetOrigin);\n  }\n\n}; // src/UserManagerSettings.ts\n\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({\n        store\n      });\n    }\n  }\n\n}; // src/navigators/IFrameWindow.ts\n\nvar IFrameWindow = class extends AbstractChildWindow {\n  constructor(_ref14) {\n    let {\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n    } = _ref14;\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    iframe.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n\n    const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n\n    this._disposeHandlers.add(() => clearTimeout(timer));\n\n    return await super.navigate(params);\n  }\n\n  close() {\n    var _a;\n\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", ev => {\n          var _a2;\n\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n\n          this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n\n      this._frame = null;\n    }\n\n    this._window = null;\n  }\n\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n\n}; // src/navigators/IFrameNavigator.ts\n\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n\n  async prepare(_ref15) {\n    let {\n      silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n    } = _ref15;\n    return new IFrameWindow({\n      silentRequestTimeoutInSeconds\n    });\n  }\n\n  async callback(url) {\n    this._logger.create(\"callback\");\n\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n\n}; // src/navigators/PopupWindow.ts\n\nvar checkForPopupClosedInterval = 500;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor(_ref16) {\n    let {\n      popupWindowTarget = DefaultPopupTarget,\n      popupWindowFeatures = {}\n    } = _ref16;\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures,\n      ...popupWindowFeatures\n    });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n  }\n\n  async navigate(params) {\n    var _a;\n\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._abort.raise(new Error(\"Popup closed by user\"));\n      }\n    }, checkForPopupClosedInterval);\n\n    this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n\n    return await super.navigate(params);\n  }\n\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n\n        this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n\n    this._window = null;\n  }\n\n  static notifyOpener(url, keepOpen) {\n    if (!window.opener) {\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    }\n\n    return super._notifyParent(window.opener, url, keepOpen);\n  }\n\n}; // src/navigators/PopupNavigator.ts\n\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n\n  async prepare(_ref17) {\n    let {\n      popupWindowFeatures = this._settings.popupWindowFeatures,\n      popupWindowTarget = this._settings.popupWindowTarget\n    } = _ref17;\n    return new PopupWindow({\n      popupWindowFeatures,\n      popupWindowTarget\n    });\n  }\n\n  async callback(url) {\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this._logger.create(\"callback\");\n\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n\n}; // src/navigators/RedirectNavigator.ts\n\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n\n  async prepare(_ref18) {\n    let {\n      redirectMethod = this._settings.redirectMethod,\n      redirectTarget = this._settings.redirectTarget\n    } = _ref18;\n\n    var _a;\n\n    this._logger.create(\"prepare\");\n\n    let targetWindow = window.self;\n\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async params => {\n        this._logger.create(\"navigate\");\n\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n\n}; // src/UserManagerEvents.ts\n\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({\n      expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds\n    });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n\n  load(user) {\n    let raiseEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super.load(user);\n\n    if (raiseEvent) {\n      this._userLoaded.raise(user);\n    }\n  }\n\n  unload() {\n    super.unload();\n\n    this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n\n\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n\n\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n\n\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n\n\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n\n\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n\n\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n\n\n  _raiseSilentRenewError(e) {\n    this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n\n\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n\n\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n\n\n  _raiseUserSignedIn() {\n    this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n\n\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n\n\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n\n\n  _raiseUserSignedOut() {\n    this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n\n\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n\n\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n\n\n  _raiseUserSessionChanged() {\n    this._userSessionChanged.raise();\n  }\n\n}; // src/SilentRenewService.ts\n\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n\n          this._retryTimer.init(5);\n\n          return;\n        }\n\n        logger2.error(\"Error from signinSilent:\", err);\n\n        this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n\n    if (!this._isStarted) {\n      this._isStarted = true;\n\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n\n      this._retryTimer.addHandler(this._tokenExpiring);\n\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n\n      this._retryTimer.removeHandler(this._tokenExpiring);\n\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n\n      this._isStarted = false;\n    }\n  }\n\n}; // src/RefreshState.ts\n\nvar RefreshState = class {\n  constructor(args) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.data = args.state;\n  }\n\n}; // src/UserManager.ts\n\nvar UserManager = class {\n  constructor(settings) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = new RedirectNavigator(this.settings);\n    this._popupNavigator = new PopupNavigator(this.settings);\n    this._iframeNavigator = new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n\n    this._sessionMonitor = null;\n\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /** Returns an object used to register for events raised by the `UserManager`. */\n\n\n  get events() {\n    return this._events;\n  }\n  /** Returns an object used to access the metadata configuration of the OIDC provider. */\n\n\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Returns promise to load the `User` object for the currently authenticated user.\n   */\n\n\n  async getUser() {\n    const logger2 = this._logger.create(\"getUser\");\n\n    const user = await this._loadUser();\n\n    if (user) {\n      logger2.info(\"user loaded\");\n\n      this._events.load(user, false);\n\n      return user;\n    }\n\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Returns promise to remove from any storage the currently authenticated user.\n   */\n\n\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n\n    this._events.unload();\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n   */\n\n\n  async signinRedirect() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._logger.create(\"signinRedirect\");\n\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({\n      redirectMethod\n    });\n    await this._signinStart({\n      request_type: \"si:r\",\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n\n\n  async signinRedirectCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n\n    const user = await this._signinEnd(url);\n\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n\n    return user;\n  }\n  /**\n   * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n   *\n   * Throws an ErrorResponse in case of wrong authentication.\n   */\n\n\n  async signinResourceOwnerCredentials(_ref19) {\n    let {\n      username,\n      password,\n      skipUserInfo = false\n    } = _ref19;\n\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n      username,\n      password,\n      skipUserInfo,\n      extraTokenParams: this.settings.extraTokenParams\n    });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n\n    return user;\n  }\n  /**\n   * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n\n\n  async signinPopup() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const logger2 = this._logger.create(\"signinPopup\");\n\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n\n    const handle = await this._popupNavigator.prepare({\n      popupWindowFeatures,\n      popupWindowTarget\n    });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      ...requestArgs\n    }, handle);\n\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n\n    return user;\n  }\n  /**\n   * Returns promise to notify the opening window of response from the authorization endpoint.\n   */\n\n\n  async signinPopupCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n\n    await this._popupNavigator.callback(url, keepOpen);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n   * The result of the promise is the authenticated `User`.\n   */\n\n\n  async signinSilent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _a;\n\n    const logger2 = this._logger.create(\"signinSilent\");\n\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user);\n      return await this._useRefreshToken(state);\n    }\n\n    const url = this.settings.silent_redirect_uri;\n\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n\n    let verifySub;\n\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      ...requestArgs\n    }, handle, verifySub);\n\n    if (user) {\n      if ((_a = user.profile) == null ? void 0 : _a.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n\n    return user;\n  }\n\n  async _useRefreshToken(state) {\n    const response = await this._client.useRefreshToken({\n      state,\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds\n    });\n    const user = new User({ ...state,\n      ...response\n    });\n    await this.storeUser(user);\n\n    this._events.load(user);\n\n    return user;\n  }\n  /**\n   * Returns promise to notify the parent window of response from the authorization endpoint.\n   */\n\n\n  async signinSilentCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n\n  async signinCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    const {\n      state\n    } = await this._client.readSigninResponseState(url);\n\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n\n      case \"si:p\":\n        return await this.signinPopupCallback(url);\n\n      case \"si:s\":\n        return await this.signinSilentCallback(url);\n\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n\n  async signoutCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      state\n    } = await this._client.readSignoutResponseState(url);\n\n    if (!state) {\n      return;\n    }\n\n    switch (state.request_type) {\n      case \"so:r\":\n        await this.signoutRedirectCallback(url);\n        break;\n\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  /**\n   * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n   */\n\n\n  async querySessionStatus() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const logger2 = this._logger.create(\"querySessionStatus\");\n\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n\n    try {\n      const signinResponse = await this._client.processSigninResponse(navResponse.url);\n      logger2.debug(\"got signin response\");\n\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub,\n          sid: signinResponse.profile.sid\n        };\n      }\n\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              session_state: err.session_state\n            };\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n\n    const signinResponse = await this._client.processSigninResponse(url);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n\n    const user = new User(signinResponse);\n\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({ ...signinResponse,\n          error: \"login_required\"\n        });\n      }\n\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n\n    this._events.load(user);\n\n    return user;\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the end session endpoint.\n   */\n\n\n  async signoutRedirect() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const logger2 = this._logger.create(\"signoutRedirect\");\n\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({\n      redirectMethod\n    });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint.\n   */\n\n\n  async signoutRedirectCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n   */\n\n\n  async signoutPopup() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const logger2 = this._logger.create(\"signoutPopup\");\n\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({\n      popupWindowFeatures,\n      popupWindowTarget\n    });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint from a popup window.\n   */\n\n\n  async signoutPopupCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n\n    await this._popupNavigator.callback(url, keepOpen);\n    logger2.info(\"success\");\n  }\n\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n\n  async _signoutStart() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let handle = arguments.length > 1 ? arguments[1] : undefined;\n\n    var _a;\n\n    const logger2 = this._logger.create(\"_signoutStart\");\n\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n\n      const id_token = args.id_token_hint || user && user.id_token;\n\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n   */\n\n\n  async signoutSilent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _a;\n\n    const logger2 = this._logger.create(\"signoutSilent\");\n\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to notify the parent window of response from the end session endpoint.\n   */\n\n\n  async signoutSilentCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n\n  async _revokeInternal(user) {\n    let types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.settings.revokeTokenTypes;\n\n    const logger2 = this._logger.create(\"_revokeInternal\");\n\n    if (!user) return;\n    const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n\n    for (const type of typesPresent) {\n      await this._client.revokeToken(user[type], // eslint-disable-line @typescript-eslint/no-non-null-assertion\n      type);\n      logger2.info(`${type} revoked successfully`);\n\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n\n    this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n\n\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n\n\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n\n      await this.settings.userStore.remove(this._userStoreKey);\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n\n\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n\n}; // package.json\n\nvar version = \"2.2.2\"; // src/Version.ts\n\nvar Version = version;\nexport { AccessTokenEvents, CheckSessionIFrame, ErrorResponse, ErrorTimeout, InMemoryWebStorage, Log, Logger, MetadataService, OidcClient, OidcClientSettingsStore, SessionMonitor, SigninResponse, SigninState, SignoutResponse, State, User, UserManager, UserManagerSettingsStore, Version, WebStorageStateStore };","map":{"version":3,"mappings":"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","names":["CryptoJS","sha256","Base64","Utf8","nopLogger","debug","info","warn","error","level","logger","Log","reset","setLevel","value","Error","setLogger","Logger","constructor","_name","args","_format","_method","throw","err","create","method","methodLogger","Object","name","staticMethod","staticLogger","prefix","UUID_V4_TEMPLATE","CryptoUtils","lib","WordArray","random","words","uuid","replace","c","_randomWord","toString","generateUUIDv4","code_verifier","hashed","stringify","client_id","client_secret","basicAuth","parse","join","Event","_logger","_callbacks","addHandler","cb","push","removeHandler","idx","lastIndexOf","splice","raise","ev","jwt_decode","JwtUtils","token","PopupUtils","features","width","_a","find","window","outerWidth","left","Math","max","round","screenX","height","top","screenY","outerHeight","entries","filter","map","key","Timer","_timerHandle","_expiration","_callback","diff","getEpochTime","cancel","floor","Date","now","init","durationInSeconds","expiration","timerDurationInSeconds","min","setInterval","clearInterval","UrlUtils","url","responseMode","TypeError","parsedUrl","URL","location","origin","params","URLSearchParams","slice","ErrorResponse","form","error_description","error_uri","_b","state","userState","session_state","_c","ErrorTimeout","message","AccessTokenEvents","_expiringTimer","_expiredTimer","_expiringNotificationTimeInSeconds","expiringNotificationTimeInSeconds","load","container","access_token","expires_in","duration","expiring","expired","unload","addAccessTokenExpiring","removeAccessTokenExpiring","addAccessTokenExpired","removeAccessTokenExpired","CheckSessionIFrame","_client_id","_intervalInSeconds","_stopOnError","_timer","_session_state","_message","e","_frame_origin","source","_frame","contentWindow","data","stop","document","createElement","style","visibility","position","src","href","Promise","resolve","onload","body","appendChild","addEventListener","start","send","postMessage","InMemoryWebStorage","_data","clear","getItem","setItem","removeItem","getOwnPropertyNames","length","index","JsonService","additionalContentTypes","_jwtHandler","_contentTypes","input","timeoutInSeconds","initFetch","fetch","controller","AbortController","timeoutId","setTimeout","abort","response","signal","DOMException","clearTimeout","credentials","headers","fetchWithTimeout","status","contentType","get","item","startsWith","ok","text","json","statusText","JSON","initCredentials","responseText","MetadataService","_settings","_jsonService","_signingKeys","_metadata","_metadataUrl","metadataUrl","signingKeys","metadata","fetchRequestCredentials","_fetchRequestCredentials","resetSigningKeys","getJson","assign","metadataSeed","getIssuer","_getMetadataProperty","getAuthorizationEndpoint","getUserInfoEndpoint","getTokenEndpoint","optional","getCheckSessionIframe","getEndSessionEndpoint","getRevocationEndpoint","getKeysEndpoint","getMetadata","jwks_uri","keySet","Array","isArray","keys","WebStorageStateStore","store","localStorage","_store","_prefix","len","indexOf","substr","DefaultResponseType","DefaultScope","DefaultClientAuthentication","DefaultResponseMode","DefaultStaleStateAgeInSeconds","DefaultClockSkewInSeconds","OidcClientSettingsStore","authority","response_type","scope","redirect_uri","post_logout_redirect_uri","client_authentication","prompt","display","max_age","ui_locales","acr_values","resource","response_mode","filterProtocolClaims","loadUserInfo","staleStateAgeInSeconds","clockSkewInSeconds","userInfoJwtIssuer","mergeClaims","disablePKCE","stateStore","refreshTokenCredentials","revokeTokenAdditionalContentTypes","refreshTokenAllowedScope","extraQueryParams","extraTokenParams","endsWith","console","UserInfoService","_metadataService","_getClaimsFromJwt","payload","decode","claims","TokenClient","grant_type","code","set","generateBasicAuth","append","postForm","refresh_token","token_type_hint","DefaultProtocolClaims","InternalRequiredProtocolClaims","ResponseValidator","_userInfoService","_tokenClient","_processSigninState","_processCode","isOpenId","_validateIdTokenAttributes","_processClaims","skipUserInfo","id_token","profile","hasIdToken","validateSignoutResponse","id","validateSub","_filterProtocolClaims","getClaims","sub","_mergeClaims","claims1","claims2","result","claim","values","previousValue","includes","protocolClaims","tokenResponse","exchangeCode","currentToken","current","auth_time","azp","State","created","request_type","toStorageString","storageString","createStatic","storage","age","cutoff","getAllKeys","i","remove","fromStorageString","SigninState","generateCodeVerifier","code_challenge","generateCodeChallenge","SigninRequest","state_data","nonce","optionalParams","searchParams","resources","forEach","r","OidcScope","SigninResponse","token_type","expires_at","Number","split","SignoutRequest","id_token_hint","SignoutResponse","OidcClient","settings","metadataService","_validator","request","request_uri","login_hint","signinRequest","clearStaleState","signinState","removeState","readParams","storedStateString","readSigninResponseState","validateSigninResponse","username","password","exchangeCredentials","signinResponse","validateCredentialsResponse","allowableScopes","providedScopes","s","exchangeRefreshToken","validateRefreshResponse","signoutState","readSignoutResponseState","type","revoke","SessionMonitor","_userManager","_start","user","_sub","_sid","sid","_checkSessionIFrame","intervalInSeconds","checkSessionIntervalInSeconds","stopOnError","stopCheckSessionOnError","checkSessionIFrame","_stop","monitorAnonymousSession","timerHandle","session","querySessionStatus","tmpUser","raiseEvent","events","_raiseUserSessionChanged","_raiseUserSignedOut","_raiseUserSignedIn","addUserLoaded","addUserUnloaded","_init","catch","getUser","User","messageSource","AbstractChildWindow","_abort","_disposeHandlers","Set","_window","keepOpen","reject","listener","scriptOrigin","_dispose","add","removeEventListener","reason","close","dispose","parent","targetOrigin","DefaultPopupWindowFeatures","toolbar","DefaultPopupTarget","DefaultAccessTokenExpiringNotificationTimeInSeconds","DefaultCheckSessionIntervalInSeconds","DefaultSilentRequestTimeoutInSeconds","UserManagerSettingsStore","popup_redirect_uri","popup_post_logout_redirect_uri","popupWindowFeatures","popupWindowTarget","redirectMethod","redirectTarget","iframeNotifyParentOrigin","iframeScriptOrigin","silent_redirect_uri","silentRequestTimeoutInSeconds","automaticSilentRenew","validateSubOnSilentRenew","includeIdTokenInSilentRenew","monitorSession","query_status_response_type","revokeTokenTypes","revokeTokensOnSignout","includeIdTokenInSilentSignout","accessTokenExpiringNotificationTimeInSeconds","userStore","sessionStorage","IFrameWindow","_timeoutInSeconds","createHiddenIframe","iframe","setAttribute","timer","navigate","parentNode","frame","target","removeChild","_notifyParent","IFrameNavigator","notifyParent","checkForPopupClosedInterval","PopupWindow","centeredPopup","center","open","serialize","focus","popupClosedInterval","closed","opener","PopupNavigator","notifyOpener","RedirectNavigator","targetWindow","self","redirect","bind","promise","UserManagerEvents","_userLoaded","_userUnloaded","_silentRenewError","_userSignedIn","_userSignedOut","_userSessionChanged","removeUserLoaded","removeUserUnloaded","addSilentRenewError","removeSilentRenewError","_raiseSilentRenewError","addUserSignedIn","removeUserSignedIn","addUserSignedOut","removeUserSignedOut","addUserSessionChanged","removeUserSessionChanged","SilentRenewService","_isStarted","_retryTimer","_tokenExpiring","signinSilent","RefreshState","UserManager","_client","_redirectNavigator","_popupNavigator","_iframeNavigator","_events","_silentRenewService","startSilentRenew","_sessionMonitor","_loadUser","storeUser","requestArgs","handle","prepare","_signinStart","_signinEnd","processResourceOwnerPasswordCredentials","_buildUser","_signin","callback","_useRefreshToken","verifySub","useRefreshToken","signinRedirectCallback","signinPopupCallback","signinSilentCallback","signoutRedirectCallback","signoutPopupCallback","signoutSilentCallback","navResponse","processSigninResponse","createSigninRequest","_signoutStart","_signoutEnd","_signout","_revokeInternal","removeUser","signoutRequest","createSignoutRequest","signoutResponse","processSignoutResponse","types","typesPresent","revokeToken","stopSilentRenew","_userStoreKey","Version","version"],"sources":["/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/CryptoUtils.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/Logger.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/Event.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/JwtUtils.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/PopupUtils.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/Timer.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/utils/UrlUtils.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/errors/ErrorResponse.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/errors/ErrorTimeout.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/AccessTokenEvents.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/CheckSessionIFrame.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/InMemoryWebStorage.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/JsonService.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/MetadataService.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/WebStorageStateStore.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/OidcClientSettings.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/UserInfoService.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/TokenClient.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/ResponseValidator.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/State.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SigninState.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SigninRequest.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SigninResponse.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SignoutRequest.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SignoutResponse.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/OidcClient.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SessionMonitor.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/User.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/navigators/AbstractChildWindow.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/UserManagerSettings.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/navigators/IFrameWindow.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/navigators/IFrameNavigator.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/navigators/PopupWindow.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/navigators/PopupNavigator.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/navigators/RedirectNavigator.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/UserManagerEvents.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/SilentRenewService.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/RefreshState.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/UserManager.ts","/srv/http/gallery-frontend/node_modules/oidc-client-ts/package.json","/srv/http/gallery-frontend/node_modules/oidc-client-ts/src/Version.ts"],"sourcesContent":["import CryptoJS from \"crypto-js/core.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport Base64 from \"crypto-js/enc-base64.js\";\nimport Utf8 from \"crypto-js/enc-utf8.js\";\n\nimport { Logger } from \"./Logger\";\n\nconst UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\n\n/**\n * @internal\n */\nexport class CryptoUtils {\n    private static _randomWord(): number {\n        return CryptoJS.lib.WordArray.random(1).words[0];\n    }\n\n    /**\n     * Generates RFC4122 version 4 guid\n     */\n    public static generateUUIDv4(): string {\n        const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c =>\n            (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16),\n        );\n        return uuid.replace(/-/g, \"\");\n    }\n\n    /**\n     * PKCE: Generate a code verifier\n     */\n    public static generateCodeVerifier(): string {\n        return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n    }\n\n    /**\n     * PKCE: Generate a code challenge\n     */\n    public static generateCodeChallenge(code_verifier: string): string {\n        try {\n            const hashed = sha256(code_verifier);\n            return Base64.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        }\n        catch (err) {\n            Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n\n    /**\n     * Generates a base64-encoded string for a basic auth header\n     */\n    public static generateBasicAuth(client_id: string, client_secret: string): string {\n        const basicAuth = Utf8.parse([client_id, client_secret].join(\":\"));\n        return Base64.stringify(basicAuth);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Native interface\n *\n * @public\n */\nexport interface ILogger {\n    debug(...args: unknown[]): void;\n    info(...args: unknown[]): void;\n    warn(...args: unknown[]): void;\n    error(...args: unknown[]): void;\n}\n\nconst nopLogger: ILogger = {\n    debug: () => undefined,\n    info: () => undefined,\n    warn: () => undefined,\n    error: () => undefined,\n};\n\nlet level: number;\nlet logger: ILogger;\n\n/**\n * Log levels\n *\n * @public\n */\nexport enum Log {\n    NONE,\n    ERROR,\n    WARN,\n    INFO,\n    DEBUG\n}\n\n/**\n * Log manager\n *\n * @public\n */\nexport namespace Log { // eslint-disable-line @typescript-eslint/no-namespace\n    export function reset(): void {\n        level = Log.INFO;\n        logger = nopLogger;\n    }\n\n    export function setLevel(value: Log): void {\n        if (!(Log.NONE <= value && value <= Log.DEBUG)) {\n            throw new Error(\"Invalid log level\");\n        }\n        level = value;\n    }\n\n    export function setLogger(value: ILogger): void {\n        logger = value;\n    }\n}\n\n/**\n * Internal logger instance\n *\n * @public\n */\nexport class Logger {\n    private _method?: string;\n    public constructor(private _name: string) {}\n\n    public debug(...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public info(...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public warn(...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public error(...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(this._name, this._method), ...args);\n        }\n    }\n\n    public throw(err: Error): never {\n        this.error(err);\n        throw err;\n    }\n\n    public create(method: string): Logger {\n        const methodLogger: Logger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n\n    public static createStatic(name: string, staticMethod: string): Logger {\n        const staticLogger = new Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n\n    private static _format(name: string, method?: string) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n\n    // helpers for static class methods\n    public static debug(name: string, ...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(name), ...args);\n        }\n    }\n    public static info(name: string, ...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(name), ...args);\n        }\n    }\n    public static warn(name: string, ...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(name), ...args);\n        }\n    }\n    public static error(name: string, ...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(name), ...args);\n        }\n    }\n}\n\nLog.reset();\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport type Callback<EventType extends unknown[]> = (...ev: EventType) => (Promise<void> | void);\n\n/**\n * @internal\n */\nexport class Event<EventType extends unknown[]> {\n    protected readonly _logger = new Logger(`Event('${this._name}')`);\n\n    private _callbacks: Array<Callback<EventType>> = [];\n\n    public constructor(protected readonly _name: string) {}\n\n    public addHandler(cb: Callback<EventType>): () => void {\n        this._callbacks.push(cb);\n        return () => this.removeHandler(cb);\n    }\n\n    public removeHandler(cb: Callback<EventType>): void {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) {\n            this._callbacks.splice(idx, 1);\n        }\n    }\n\n    public raise(...ev: EventType): void {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks) {\n            void cb(...ev);\n        }\n    }\n}\n","import jwt_decode from \"jwt-decode\";\n\nimport { Logger } from \"./Logger\";\nimport type { JwtClaims } from \"../Claims\";\n\n/**\n * @internal\n */\nexport class JwtUtils {\n    // IMPORTANT: doesn't validate the token\n    public static decode(token: string): JwtClaims {\n        try {\n            return jwt_decode<JwtClaims>(token);\n        }\n        catch (err) {\n            Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n}\n","/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n *\n * @public\n */\nexport interface PopupWindowFeatures {\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    menubar?: boolean | string;\n    toolbar?: boolean | string;\n    location?: boolean | string;\n    status?: boolean | string;\n    resizable?: boolean | string;\n    scrollbars?: boolean | string;\n\n    [k: string]: boolean | string | number | undefined;\n}\n\nexport class PopupUtils {\n    /**\n     * Populates a map of window features with a placement centered in front of\n     * the current window. If no explicit width is given, a default value is\n     * binned into [800, 720, 600, 480, 360] based on the current window's width.\n     */\n    static center({ ...features }: PopupWindowFeatures): PopupWindowFeatures {\n        if (features.width == null)\n            features.width = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618) ?? 360;\n        features.left ??= Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null)\n            features.top ??= Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n\n    static serialize(features: PopupWindowFeatures): string {\n        return Object.entries(features)\n            .filter(([, value]) => value != null)\n            .map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value as string : value ? \"yes\" : \"no\"}`)\n            .join(\",\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event } from \"./Event\";\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport class Timer extends Event<[void]> {\n    protected readonly _logger = new Logger(`Timer('${this._name}')`);\n    private _timerHandle: ReturnType<typeof setInterval> | null = null;\n    private _expiration = 0;\n\n    // get the time\n    public static getEpochTime(): number {\n        return Math.floor(Date.now() / 1000);\n    }\n\n    public init(durationInSeconds: number): void {\n        const logger = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            // no need to reinitialize to same expiration, so bail out\n            logger.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n\n        this.cancel();\n\n        logger.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n\n        // we're using a fairly short timer and then checking the expiration in the\n        // callback to handle scenarios where the browser device sleeps, and then\n        // the timers end up getting delayed.\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1000);\n    }\n\n    public get expiration(): number {\n        return this._expiration;\n    }\n\n    public cancel(): void {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n\n    protected _callback = (): void => {\n        const diff = this._expiration - Timer.getEpochTime();\n        this._logger.debug(\"timer completes in\", diff);\n\n        if (this._expiration <= Timer.getEpochTime()) {\n            this.cancel();\n            super.raise();\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @internal\n */\nexport class UrlUtils {\n    public static readParams(url: string, responseMode: \"query\" | \"fragment\" = \"query\"): URLSearchParams {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        const parsedUrl = new URL(url, window.location.origin);\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\n\n/**\n * Error class thrown in case of an authentication error.\n *\n * See https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n *\n * @public\n */\nexport class ErrorResponse extends Error {\n    /** Marker to detect class: \"ErrorResponse\" */\n    public readonly name: string = \"ErrorResponse\";\n\n    /** An error code string that can be used to classify the types of errors that occur and to respond to errors. */\n    public readonly error: string | null;\n    /** additional information that can help a developer identify the cause of the error.*/\n    public readonly error_description: string | null;\n    /**\n     * URI identifying a human-readable web page with information about the error, used to provide the client\n       developer with additional information about the error.\n    */\n    public readonly error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public state?: unknown;\n\n    public readonly session_state: string | null;\n\n    public constructor(\n        args: {\n            error?: string | null; error_description?: string | null; error_uri?: string | null;\n            userState?: unknown; session_state?: string | null;\n        },\n        /** The x-www-form-urlencoded request body sent to the authority server */\n        public readonly form?: URLSearchParams,\n    ) {\n        super(args.error_description || args.error || \"\");\n\n        if (!args.error) {\n            Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n\n        this.error = args.error;\n        this.error_description = args.error_description ?? null;\n        this.error_uri = args.error_uri ?? null;\n\n        this.state = args.userState;\n        this.session_state = args.session_state ?? null;\n    }\n}\n","// Copyright (C) 2021 AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Error class thrown in case of network timeouts (e.g IFrame time out).\n *\n * @public\n */\nexport class ErrorTimeout extends Error {\n    /** Marker to detect class: \"ErrorTimeout\" */\n    public readonly name: string = \"ErrorTimeout\";\n\n    public constructor(message?: string) {\n        super(message);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type AccessTokenCallback = (...ev: unknown[]) => (Promise<void> | void);\n\n/**\n * @public\n */\nexport class AccessTokenEvents {\n    protected readonly _logger = new Logger(\"AccessTokenEvents\");\n\n    private readonly _expiringTimer = new Timer(\"Access token expiring\");\n    private readonly _expiredTimer = new Timer(\"Access token expired\");\n    private readonly _expiringNotificationTimeInSeconds: number;\n\n    public constructor(args: { expiringNotificationTimeInSeconds: number }) {\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n\n    public load(container: User): void {\n        const logger = this._logger.create(\"load\");\n        // only register events if there's an access token and it has an expiration\n        if (container.access_token && container.expires_in !== undefined) {\n            const duration = container.expires_in;\n            logger.debug(\"access token present, remaining duration:\", duration);\n\n            if (duration > 0) {\n                // only register expiring if we still have time\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) {\n                    expiring = 1;\n                }\n\n                logger.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            }\n            else {\n                logger.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n\n            // if it's negative, it will still fire\n            const expired = duration + 1;\n            logger.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        }\n        else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n\n    public unload(): void {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n\n    /**\n     * Add callback: Raised prior to the access token expiring.\n     */\n    public addAccessTokenExpiring(cb: AccessTokenCallback): () => void {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised prior to the access token expiring.\n     */\n    public removeAccessTokenExpiring(cb: AccessTokenCallback): void {\n        this._expiringTimer.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised after the access token has expired.\n     */\n    public addAccessTokenExpired(cb: AccessTokenCallback): () => void {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised after the access token has expired.\n     */\n    public removeAccessTokenExpired(cb: AccessTokenCallback): void {\n        this._expiredTimer.removeHandler(cb);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport class CheckSessionIFrame {\n    private readonly _logger = new Logger(\"CheckSessionIFrame\");\n    private _frame_origin: string;\n    private _frame: HTMLIFrameElement;\n    private _timer: ReturnType<typeof setInterval> | null = null;\n    private _session_state: string | null = null;\n\n    public constructor(\n        private _callback: () => Promise<void>,\n        private _client_id: string,\n        url: string,\n        private _intervalInSeconds: number,\n        private _stopOnError: boolean,\n    ) {\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n\n        this._frame = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n\n    public load(): Promise<void> {\n        return new Promise<void>((resolve) => {\n            this._frame.onload = () => {\n                resolve();\n            };\n\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n\n    private _message = (e: MessageEvent<string>): void => {\n        if (e.origin === this._frame_origin &&\n            e.source === this._frame.contentWindow\n        ) {\n            if (e.data === \"error\") {\n                this._logger.error(\"error message from check session op iframe\");\n                if (this._stopOnError) {\n                    this.stop();\n                }\n            }\n            else if (e.data === \"changed\") {\n                this._logger.debug(\"changed message from check session op iframe\");\n                this.stop();\n                void this._callback();\n            }\n            else {\n                this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        }\n    };\n\n    public start(session_state: string): void {\n        if (this._session_state === session_state) {\n            return;\n        }\n\n        this._logger.create(\"start\");\n\n        this.stop();\n\n        this._session_state = session_state;\n\n        const send = () => {\n            if (!this._frame.contentWindow || !this._session_state) {\n                return;\n            }\n\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n\n        // trigger now\n        send();\n\n        // and setup timer\n        this._timer = setInterval(send, this._intervalInSeconds * 1000);\n    }\n\n    public stop(): void {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n\n        if (this._timer) {\n\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @public\n */\nexport class InMemoryWebStorage implements Storage {\n    private readonly _logger = new Logger(\"InMemoryWebStorage\");\n    private _data: Record<string, string> = {};\n\n    public clear(): void {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n\n    public getItem(key: string): string {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n\n    public setItem(key: string, value: string): void {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n\n    public removeItem(key: string): void {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n\n    public get length(): number {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n\n    public key(index: number): string {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { ErrorResponse, ErrorTimeout } from \"./errors\";\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport type JwtHandler = (text: string) => Promise<Record<string, unknown>>;\n\n/**\n * @internal\n */\nexport interface GetJsonOpts {\n    token?: string;\n    credentials?: RequestCredentials;\n}\n\n/**\n * @internal\n */\nexport interface PostFormOpts {\n    body: URLSearchParams;\n    basicAuth?: string;\n    timeoutInSeconds?: number;\n    initCredentials?: \"same-origin\" | \"include\" | \"omit\";\n}\n\n/**\n * @internal\n */\nexport class JsonService {\n    private readonly _logger = new Logger(\"JsonService\");\n\n    private _contentTypes: string[] = [];\n\n    public constructor(\n        additionalContentTypes: string[] = [],\n        private _jwtHandler: JwtHandler | null = null,\n    ) {\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) {\n            this._contentTypes.push(\"application/jwt\");\n        }\n    }\n\n    protected async fetchWithTimeout(input: RequestInfo, init: RequestInit & { timeoutInSeconds?: number } = {}) {\n        const { timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) {\n            return await fetch(input, initFetch);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal,\n            });\n            return response;\n        }\n        catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") {\n                throw new ErrorTimeout(\"Network timed out\");\n            }\n            throw err;\n        }\n        finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    public async getJson(url: string, {\n        token,\n        credentials,\n    }: GetJsonOpts = {}): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"getJson\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n        };\n        if (token) {\n            logger.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"GET\", headers, credentials });\n        }\n        catch (err) {\n            logger.error(\"Network Error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            logger.throw(new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`));\n        }\n        if (response.ok && this._jwtHandler && contentType?.startsWith(\"application/jwt\")) {\n            return await this._jwtHandler(await response.text());\n        }\n        let json: Record<string, unknown>;\n        try {\n            json = await response.json();\n        }\n        catch (err) {\n            logger.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n\n    public async postForm(url: string, {\n        body,\n        basicAuth,\n        timeoutInSeconds,\n        initCredentials,\n    }: PostFormOpts): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"postForm\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        };\n        if (basicAuth !== undefined) {\n            headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        }\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n        }\n        catch (err) {\n            logger.error(\"Network error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            throw new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`);\n        }\n\n        const responseText = await response.text();\n\n        let json: Record<string, unknown> = {};\n        if (responseText) {\n            try {\n                json = JSON.parse(responseText);\n            }\n            catch (err) {\n                logger.error(\"Error parsing JSON response\", err);\n                if (response.ok) throw err;\n                throw new Error(`${response.statusText} (${response.status})`);\n            }\n        }\n\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json, body);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n\n        return json;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { OidcClientSettingsStore, SigningKey } from \"./OidcClientSettings\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\n\n/**\n * @public\n */\nexport class MetadataService {\n    private readonly _logger = new Logger(\"MetadataService\");\n    private readonly _jsonService = new JsonService([\"application/jwk-set+json\"]);\n\n    // cache\n    private _metadataUrl: string;\n    private _signingKeys: SigningKey[] | null = null;\n    private _metadata: Partial<OidcMetadata> | null = null;\n    private _fetchRequestCredentials: RequestCredentials | undefined;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore) {\n        this._metadataUrl = this._settings.metadataUrl;\n\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n\n    public resetSigningKeys(): void {\n        this._signingKeys = null;\n    }\n\n    public async getMetadata(): Promise<Partial<OidcMetadata>> {\n        const logger = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger.debug(\"using cached values\");\n            return this._metadata;\n        }\n\n        if (!this._metadataUrl) {\n            logger.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            throw null;\n        }\n\n        logger.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });\n\n        logger.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n        return this._metadata;\n    }\n\n    public getIssuer(): Promise<string> {\n        return this._getMetadataProperty(\"issuer\") as Promise<string>;\n    }\n\n    public getAuthorizationEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"authorization_endpoint\") as Promise<string>;\n    }\n\n    public getUserInfoEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"userinfo_endpoint\") as Promise<string>;\n    }\n\n    public getTokenEndpoint(optional: false): Promise<string>;\n    public getTokenEndpoint(optional?: true): Promise<string | undefined>;\n    public getTokenEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"token_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getCheckSessionIframe(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"check_session_iframe\", true) as Promise<string | undefined>;\n    }\n\n    public getEndSessionEndpoint(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"end_session_endpoint\", true) as Promise<string | undefined>;\n    }\n\n    public getRevocationEndpoint(optional: false): Promise<string>;\n    public getRevocationEndpoint(optional?: true): Promise<string | undefined>;\n    public getRevocationEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getKeysEndpoint(optional: false): Promise<string>;\n    public getKeysEndpoint(optional?: true): Promise<string | undefined>;\n    public getKeysEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"jwks_uri\", optional) as Promise<string | undefined>;\n    }\n\n    protected async _getMetadataProperty(name: keyof OidcMetadata, optional=false): Promise<string | boolean | string[] | undefined> {\n        const logger = this._logger.create(`_getMetadataProperty('${name}')`);\n\n        const metadata = await this.getMetadata();\n        logger.debug(\"resolved\");\n\n        if (metadata[name] === undefined) {\n            if (optional === true) {\n                logger.warn(\"Metadata does not contain optional property\");\n                return undefined;\n            }\n\n            logger.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n\n        return metadata[name];\n    }\n\n    public async getSigningKeys(): Promise<SigningKey[] | null> {\n        const logger = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger.debug(\"got jwks_uri\", jwks_uri);\n\n        const keySet = await this._jsonService.getJson(jwks_uri);\n        logger.debug(\"got key set\", keySet);\n\n        if (!Array.isArray(keySet.keys)) {\n            logger.throw(new Error(\"Missing keys on keyset\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\nimport type { AsyncStorage } from \"./AsyncStorage\";\n\n/**\n * @public\n */\nexport class WebStorageStateStore implements StateStore {\n    private readonly _logger = new Logger(\"WebStorageStateStore\");\n\n    private readonly _store: AsyncStorage | Storage;\n    private readonly _prefix: string;\n\n    public constructor({\n        prefix = \"oidc.\",\n        store = localStorage,\n    }: { prefix?: string; store?: AsyncStorage | Storage } = {}) {\n        this._store = store;\n        this._prefix = prefix;\n    }\n\n    public async set(key: string, value: string): Promise<void> {\n        this._logger.create(`set('${key}')`);\n\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n\n    public async get(key: string): Promise<string | null> {\n        this._logger.create(`get('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n\n    public async remove(key: string): Promise<string | null> {\n        this._logger.create(`remove('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n\n        const keys = [];\n        for (let index = 0; index < len; index++) {\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) {\n                keys.push(key.substr(this._prefix.length));\n            }\n        }\n        return keys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\nimport type { StateStore } from \"./StateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\n\nconst DefaultResponseType = \"code\";\nconst DefaultScope = \"openid\";\nconst DefaultClientAuthentication = \"client_secret_post\";\nconst DefaultResponseMode = \"query\";\nconst DefaultStaleStateAgeInSeconds = 60 * 15;\nconst DefaultClockSkewInSeconds = 60 * 5;\n\n/**\n * @public\n */\nexport type SigningKey = Record<string, string | string[]>;\n\n/**\n * The settings used to configure the {@link OidcClient}.\n *\n * @public\n */\nexport interface OidcClientSettings {\n    /** The URL of the OIDC/OAuth2 provider */\n    authority: string;\n    metadataUrl?: string;\n    /** Provide metadata when authority server does not allow CORS on the metadata endpoint */\n    metadata?: Partial<OidcMetadata>;\n    /** Can be used to seed or add additional values to the results of the discovery request */\n    metadataSeed?: Partial<OidcMetadata>;\n    /** Provide signingKeys when authority server does not allow CORS on the jwks uri */\n    signingKeys?: SigningKey[];\n\n    /** Your client application's identifier as registered with the OIDC/OAuth2 */\n    client_id: string;\n    client_secret?: string;\n    /** The type of response desired from the OIDC/OAuth2 provider (default: \"code\") */\n    response_type?: string;\n    /** The scope being requested from the OIDC/OAuth2 provider (default: \"openid\") */\n    scope?: string;\n    /** The redirect URI of your client application to receive a response from the OIDC/OAuth2 provider */\n    redirect_uri: string;\n    /** The OIDC/OAuth2 post-logout redirect URI */\n    post_logout_redirect_uri?: string;\n\n    /**\n     * Client authentication method that is used to authenticate when using the token endpoint (default: \"client_secret_post\")\n     * - \"client_secret_basic\": using the HTTP Basic authentication scheme\n     * - \"client_secret_post\": including the client credentials in the request body\n     *\n     * See https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n     */\n    client_authentication?: \"client_secret_basic\" | \"client_secret_post\";\n\n    /** optional protocol param */\n    prompt?: string;\n    /** optional protocol param */\n    display?: string;\n    /** optional protocol param */\n    max_age?: number;\n    /** optional protocol param */\n    ui_locales?: string;\n    /** optional protocol param */\n    acr_values?: string;\n    /** optional protocol param */\n    resource?: string | string[];\n\n    /** optional protocol param (default: \"query\") */\n    response_mode?: \"query\" | \"fragment\";\n\n    /**\n     * Should optional OIDC protocol claims be removed from profile or specify the ones to be removed (default: true)\n     * When true, the following claims are removed by default: [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"]\n     * When specifying claims, the following claims are not allowed: [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"]\n    */\n    filterProtocolClaims?: boolean | string[];\n    /** Flag to control if additional identity data is loaded from the user info endpoint in order to populate the user's profile (default: false) */\n    loadUserInfo?: boolean;\n    /** Number (in seconds) indicating the age of state entries in storage for authorize requests that are considered abandoned and thus can be cleaned up (default: 900) */\n    staleStateAgeInSeconds?: number;\n\n    /** @deprecated Unused */\n    clockSkewInSeconds?: number;\n    /** @deprecated Unused */\n    userInfoJwtIssuer?: \"ANY\" | \"OP\" | string;\n\n    /**\n     * Indicates if objects returned from the user info endpoint as claims (e.g. `address`) are merged into the claims from the id token as a single object.\n     * Otherwise, they are added to an array as distinct objects for the claim type. (default: false)\n     */\n    mergeClaims?: boolean;\n\n    /**\n     * Storage object used to persist interaction state (default: window.localStorage, InMemoryWebStorage iff no window).\n     * E.g. `stateStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    stateStore?: StateStore;\n\n    /**\n     * An object containing additional query string parameters to be including in the authorization request.\n     * E.g, when using Azure AD to obtain an access token an additional resource parameter is required. extraQueryParams: `{resource:\"some_identifier\"}`\n     */\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    extraTokenParams?: Record<string, unknown>;\n\n    /**\n     * @deprecated since version 2.1.0. Use fetchRequestCredentials instead.\n     */\n    refreshTokenCredentials?: \"same-origin\" | \"include\" | \"omit\";\n\n    /**\n     * Will check the content type header of the response of the revocation endpoint to match these passed values (default: [])\n     */\n    revokeTokenAdditionalContentTypes?: string[];\n    /**\n     * Will disable pkce validation, changing to true will not append to sign in request code_challenge and code_challenge_method. (default: false)\n     */\n    disablePKCE?: boolean;\n    /**\n     * Sets the credentials for fetch requests. (default: \"same-origin\")\n     * Use this if you need to send cookies to the OIDC/OAuth2 provider or if you are using a proxy that requires cookies\n     */\n    fetchRequestCredentials?: RequestCredentials;\n\n    /**\n     * Only scopes in this list will be passed in the token refresh request.\n     */\n    refreshTokenAllowedScope?: string | undefined;\n}\n\n/**\n * The settings with defaults applied of the {@link OidcClient}.\n * @see {@link OidcClientSettings}\n *\n * @public\n */\nexport class OidcClientSettingsStore {\n    // metadata\n    public readonly authority: string;\n    public readonly metadataUrl: string;\n    public readonly metadata: Partial<OidcMetadata> | undefined;\n    public readonly metadataSeed: Partial<OidcMetadata> | undefined;\n    public readonly signingKeys: SigningKey[] | undefined;\n\n    // client config\n    public readonly client_id: string;\n    public readonly client_secret: string | undefined;\n    public readonly response_type: string;\n    public readonly scope: string;\n    public readonly redirect_uri: string;\n    public readonly post_logout_redirect_uri: string | undefined;\n    public readonly client_authentication: \"client_secret_basic\" | \"client_secret_post\";\n\n    // optional protocol params\n    public readonly prompt: string | undefined;\n    public readonly display: string | undefined;\n    public readonly max_age: number | undefined;\n    public readonly ui_locales: string | undefined;\n    public readonly acr_values: string | undefined;\n    public readonly resource: string | string[] | undefined;\n    public readonly response_mode: \"query\" | \"fragment\";\n\n    // behavior flags\n    public readonly filterProtocolClaims: boolean | string[];\n    public readonly loadUserInfo: boolean;\n    public readonly staleStateAgeInSeconds: number;\n    public readonly clockSkewInSeconds: number;\n    public readonly userInfoJwtIssuer: \"ANY\" | \"OP\" | string;\n    public readonly mergeClaims: boolean;\n\n    public readonly stateStore: StateStore;\n\n    // extra\n    public readonly extraQueryParams: Record<string, string | number | boolean>;\n    public readonly extraTokenParams: Record<string, unknown>;\n\n    public readonly revokeTokenAdditionalContentTypes?: string[];\n    public readonly fetchRequestCredentials: RequestCredentials;\n    public readonly refreshTokenAllowedScope: string | undefined;\n    public readonly disablePKCE: boolean;\n    \n    public constructor({\n        // metadata related\n        authority, metadataUrl, metadata, signingKeys, metadataSeed,\n        // client related\n        client_id, client_secret, response_type = DefaultResponseType, scope = DefaultScope,\n        redirect_uri, post_logout_redirect_uri,\n        client_authentication = DefaultClientAuthentication,\n        // optional protocol\n        prompt, display, max_age, ui_locales, acr_values, resource, response_mode = DefaultResponseMode,\n        // behavior flags\n        filterProtocolClaims = true,\n        loadUserInfo = false,\n        staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n        clockSkewInSeconds = DefaultClockSkewInSeconds,\n        userInfoJwtIssuer = \"OP\",\n        mergeClaims = false,\n        disablePKCE = false,\n        // other behavior\n        stateStore,\n        refreshTokenCredentials,\n        revokeTokenAdditionalContentTypes,\n        fetchRequestCredentials,\n        refreshTokenAllowedScope,\n        // extra query params\n        extraQueryParams = {},\n        extraTokenParams = {},\n    }: OidcClientSettings) {\n\n        this.authority = authority;\n\n        if (metadataUrl) {\n            this.metadataUrl = metadataUrl;\n        } else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) {\n                    this.metadataUrl += \"/\";\n                }\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n\n        this.filterProtocolClaims = filterProtocolClaims ?? true;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.clockSkewInSeconds = clockSkewInSeconds;\n        this.userInfoJwtIssuer = userInfoJwtIssuer;\n        this.mergeClaims = !!mergeClaims;\n        this.disablePKCE = !!disablePKCE;\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n        if (fetchRequestCredentials && refreshTokenCredentials) {\n            console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n        }\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials\n            : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n\n        if (stateStore) {\n            this.stateStore = stateStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n            this.stateStore = new WebStorageStateStore({ store });\n        }\n\n        this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport class UserInfoService {\n    protected readonly _logger = new Logger(\"UserInfoService\");\n    private readonly _jsonService: JsonService;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(undefined, this._getClaimsFromJwt);\n    }\n\n    public async getClaims(token: string): Promise<JwtClaims> {\n        const logger = this._logger.create(\"getClaims\");\n        if (!token) {\n            this._logger.throw(new Error(\"No token passed\"));\n        }\n\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger.debug(\"got userinfo url\", url);\n\n        const claims = await this._jsonService.getJson(url, {\n            token,\n            credentials: this._settings.fetchRequestCredentials,\n        });\n        logger.debug(\"got claims\", claims);\n\n        return claims;\n    }\n\n    protected _getClaimsFromJwt = async (responseText: string): Promise<JwtClaims> => {\n        const logger = this._logger.create(\"_getClaimsFromJwt\");\n        try {\n            const payload = JwtUtils.decode(responseText);\n            logger.debug(\"JWT decoding successful\");\n\n            return payload;\n        } catch (err) {\n            logger.error(\"Error parsing JWT response\");\n            throw err;\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport interface ExchangeCodeArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    code: string;\n    code_verifier?: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeCredentialsArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    scope?: string;\n\n    username: string;\n    password: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeRefreshTokenArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    refresh_token: string;\n    scope?: string;\n\n    timeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport interface RevokeArgs {\n    token: string;\n    token_type_hint?: \"access_token\" | \"refresh_token\";\n}\n\n/**\n * @internal\n */\nexport class TokenClient {\n    private readonly _logger = new Logger(\"TokenClient\");\n    private readonly _jsonService;\n\n    public constructor(\n        private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(this._settings.revokeTokenAdditionalContentTypes);\n    }\n\n    public async exchangeCode({\n        grant_type = \"authorization_code\",\n        redirect_uri = this._settings.redirect_uri,\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        ...args\n    }: ExchangeCodeArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCode\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!redirect_uri) {\n            logger.throw(new Error(\"A redirect_uri is required\"));\n        }\n        if (!args.code) {\n            logger.throw(new Error(\"A code is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, redirect_uri });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    public async exchangeCredentials({\n        grant_type = \"password\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        scope = this._settings.scope,\n        ...args\n    }: ExchangeCredentialsArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCredentials\");\n\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, scope });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    public async exchangeRefreshToken({\n        grant_type = \"refresh_token\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        timeoutInSeconds,\n        ...args\n    }: ExchangeRefreshTokenArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!args.refresh_token) {\n            logger.throw(new Error(\"A refresh_token is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Revoke an access or refresh token.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n     */\n    public async revoke(args: RevokeArgs): Promise<void> {\n        const logger = this._logger.create(\"revoke\");\n        if (!args.token) {\n            logger.throw(new Error(\"A token is required\"));\n        }\n\n        const url = await this._metadataService.getRevocationEndpoint(false);\n\n        logger.debug(`got revocation endpoint, revoking ${args.token_type_hint ?? \"default token type\"}`);\n\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) {\n            params.set(\"client_secret\", this._settings.client_secret);\n        }\n\n        await this._jsonService.postForm(url, { body: params });\n        logger.debug(\"got response\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { UserInfoService } from \"./UserInfoService\";\nimport { TokenClient } from \"./TokenClient\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { SigninState } from \"./SigninState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { State } from \"./State\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { UserProfile } from \"./User\";\nimport type { RefreshState } from \"./RefreshState\";\nimport type { JwtClaims, IdTokenClaims } from \"./Claims\";\n\n/**\n * Protocol claims that could be removed by default from profile.\n * Derived from the following sets of claims:\n * - {@link https://datatracker.ietf.org/doc/html/rfc7519.html#section-4.1}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#IDToken}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken}\n *\n * @internal\n */\nconst DefaultProtocolClaims = [\n    \"nbf\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    \"at_hash\", // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n] as const;\n\n/**\n * Protocol claims that should never be removed from profile.\n * \"sub\" is needed internally and others should remain required as per the OIDC specs.\n *\n * @internal\n */\nconst InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\n\n/**\n * @internal\n */\nexport class ResponseValidator {\n    protected readonly _logger = new Logger(\"ResponseValidator\");\n    protected readonly _userInfoService = new UserInfoService(this._settings, this._metadataService);\n    protected readonly _tokenClient = new TokenClient(this._settings, this._metadataService);\n\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n        protected readonly _metadataService: MetadataService,\n    ) {}\n\n    public async validateSigninResponse(response: SigninResponse, state: SigninState): Promise<void> {\n        const logger = this._logger.create(\"validateSigninResponse\");\n\n        this._processSigninState(response, state);\n        logger.debug(\"state processed\");\n\n        await this._processCode(response, state);\n        logger.debug(\"code processed\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, state?.skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateCredentialsResponse(response: SigninResponse, skipUserInfo: boolean): Promise<void> {\n        const logger = this._logger.create(\"validateCredentialsResponse\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateRefreshResponse(response: SigninResponse, state: RefreshState): Promise<void> {\n        const logger = this._logger.create(\"validateRefreshResponse\");\n\n        response.userState = state.data;\n        // if there's no session_state on the response, copy over session_state from original request\n        response.session_state ??= state.session_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        // OpenID Connect Core 1.0 says that id_token is optional in refresh response:\n        // https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokenResponse\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger.debug(\"ID Token validated\");\n        }\n\n        if (!response.id_token) {\n            // if there's no id_token on the response, copy over id_token from original request\n            response.id_token = state.id_token;\n            // and decoded part too\n            response.profile = state.profile;\n        }\n\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger.debug(\"claims processed\");\n    }\n\n    public validateSignoutResponse(response: SignoutResponse, state: State): void {\n        const logger = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n    }\n\n    protected _processSigninState(response: SigninResponse, state: SigninState): void {\n        const logger = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        if (!state.client_id) {\n            logger.throw(new Error(\"No client_id on state\"));\n        }\n\n        if (!state.authority) {\n            logger.throw(new Error(\"No authority on state\"));\n        }\n\n        // ensure we're using the correct authority\n        if (this._settings.authority !== state.authority) {\n            logger.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        }\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n            logger.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n\n        if (state.code_verifier && !response.code) {\n            logger.throw(new Error(\"Expected code in response\"));\n        }\n\n    }\n\n    protected async _processClaims(response: SigninResponse, skipUserInfo = false, validateSub = true): Promise<void> {\n        const logger = this._logger.create(\"_processClaims\");\n        response.profile = this._filterProtocolClaims(response.profile);\n\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger.debug(\"not loading user info\");\n            return;\n        }\n\n        logger.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger.debug(\"user info claims received from user info endpoint\");\n\n        if (validateSub && claims.sub !== response.profile.sub) {\n            logger.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        }\n\n        response.profile = this._mergeClaims(response.profile, this._filterProtocolClaims(claims as IdTokenClaims));\n        logger.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n\n    protected _mergeClaims(claims1: UserProfile, claims2: JwtClaims): UserProfile {\n        const result = { ...claims1 };\n\n        for (const [claim, values] of Object.entries(claims2)) {\n            for (const value of Array.isArray(values) ? values : [values]) {\n                const previousValue = result[claim];\n                if (!previousValue) {\n                    result[claim] = value;\n                }\n                else if (Array.isArray(previousValue)) {\n                    if (!previousValue.includes(value)) {\n                        previousValue.push(value);\n                    }\n                }\n                else if (result[claim] !== value) {\n                    if (typeof value === \"object\" && this._settings.mergeClaims) {\n                        result[claim] = this._mergeClaims(previousValue as UserProfile, value);\n                    }\n                    else {\n                        result[claim] = [previousValue, value];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    protected _filterProtocolClaims(claims: UserProfile): UserProfile {\n        const result = { ...claims };\n\n        if (this._settings.filterProtocolClaims) {\n            let protocolClaims;\n            if (Array.isArray(this._settings.filterProtocolClaims)) {\n                protocolClaims = this._settings.filterProtocolClaims;\n            } else {\n                protocolClaims = DefaultProtocolClaims;\n            }\n\n            for (const claim of protocolClaims) {\n                if (!InternalRequiredProtocolClaims.includes(claim)) {\n                    delete result[claim];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    protected async _processCode(response: SigninResponse, state: SigninState): Promise<void> {\n        const logger = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                ...state.extraTokenParams,\n            });\n            Object.assign(response, tokenResponse);\n        } else {\n            logger.debug(\"No code to process\");\n        }\n    }\n\n    protected _validateIdTokenAttributes(response: SigninResponse, currentToken?: string): void {\n        const logger = this._logger.create(\"_validateIdTokenAttributes\");\n\n        logger.debug(\"decoding ID Token JWT\");\n        const profile = JwtUtils.decode(response.id_token ?? \"\");\n\n        if (!profile.sub) {\n            logger.throw(new Error(\"ID Token is missing a subject claim\"));\n        }\n\n        if (currentToken) {\n            const current = JwtUtils.decode(currentToken);\n            if (current.sub !== profile.sub) {\n                logger.throw(new Error(\"sub in id_token does not match current sub\"));\n            }\n            if (current.auth_time && current.auth_time !== profile.auth_time) {\n                logger.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            }\n            if (current.azp && current.azp !== profile.azp) {\n                logger.throw(new Error(\"azp in id_token does not match original azp\"));\n            }\n            if (!current.azp && profile.azp) {\n                logger.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n            }\n        }\n\n        response.profile = profile as UserProfile;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils, Timer } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\n\n/**\n * @public\n */\nexport class State {\n    public readonly id: string;\n    public readonly created: number;\n    public readonly request_type: string | undefined;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data: unknown | undefined;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n    }) {\n        this.id = args.id || CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n\n        if (args.created && args.created > 0) {\n            this.created = args.created;\n        }\n        else {\n            this.created = Timer.getEpochTime();\n        }\n        this.request_type = args.request_type;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n        });\n    }\n\n    public static fromStorageString(storageString: string): State {\n        Logger.createStatic(\"State\", \"fromStorageString\");\n        return new State(JSON.parse(storageString));\n    }\n\n    public static async clearStaleState(storage: StateStore, age: number): Promise<void> {\n        const logger = Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = Timer.getEpochTime() - age;\n\n        const keys = await storage.getAllKeys();\n        logger.debug(\"got keys\", keys);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n\n            if (item) {\n                try {\n                    const state = State.fromStorageString(item);\n\n                    logger.debug(\"got item from key:\", key, state.created);\n                    if (state.created <= cutoff) {\n                        remove = true;\n                    }\n                }\n                catch (err) {\n                    logger.error(\"Error parsing state for key:\", key, err);\n                    remove = true;\n                }\n            }\n            else {\n                logger.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n\n            if (remove) {\n                logger.debug(\"removed item for key:\", key);\n                void storage.remove(key);\n            }\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n */\nexport class SigninState extends State {\n    // isCode\n    /** The same code_verifier that was used to obtain the authorization_code via PKCE. */\n    public readonly code_verifier: string | undefined;\n    /** Used to secure authorization code grants via Proof Key for Code Exchange (PKCE). */\n    public readonly code_challenge: string | undefined;\n\n    // to ensure state still matches settings\n    /** @see {@link OidcClientSettings.authority} */\n    public readonly authority: string;\n    /** @see {@link OidcClientSettings.client_id} */\n    public readonly client_id: string;\n    /** @see {@link OidcClientSettings.redirect_uri} */\n    public readonly redirect_uri: string;\n    /** @see {@link OidcClientSettings.scope} */\n    public readonly scope: string;\n    /** @see {@link OidcClientSettings.client_secret} */\n    public readonly client_secret: string | undefined;\n    /** @see {@link OidcClientSettings.extraTokenParams} */\n    public readonly extraTokenParams: Record<string, unknown> | undefined;\n    /** @see {@link OidcClientSettings.response_mode} */\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    public readonly skipUserInfo: boolean | undefined;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n\n        code_verifier?: string | boolean;\n        authority: string;\n        client_id: string;\n        redirect_uri: string;\n        scope: string;\n        client_secret?: string;\n        extraTokenParams?: Record<string, unknown>;\n        response_mode?: \"query\" | \"fragment\";\n        skipUserInfo?: boolean;\n    }) {\n        super(args);\n\n        if (args.code_verifier === true) {\n            this.code_verifier = CryptoUtils.generateCodeVerifier();\n        }\n        else if (args.code_verifier) {\n            this.code_verifier = args.code_verifier;\n        }\n\n        if (this.code_verifier) {\n            this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n        }\n\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams : this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo,\n        });\n    }\n\n    public static fromStorageString(storageString: string): SigninState {\n        Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return new SigninState(data);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { SigninState } from \"./SigninState\";\n\n/**\n * @public\n */\nexport interface SigninRequestArgs {\n    // mandatory\n    url: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    response_type: string;\n    scope: string;\n\n    // optional\n    prompt?: string;\n    display?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n    resource?: string | string[];\n    response_mode?: \"query\" | \"fragment\" ;\n    request?: string;\n    request_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n    request_type?: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    skipUserInfo?: boolean;\n    nonce?: string;\n    disablePKCE?: boolean;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n}\n\n/**\n * @public\n */\nexport class SigninRequest {\n    private readonly _logger = new Logger(\"SigninRequest\");\n\n    public readonly url: string;\n    public readonly state: SigninState;\n\n    public constructor({\n        // mandatory\n        url, authority, client_id, redirect_uri, response_type, scope,\n        // optional\n        state_data, response_mode, request_type, client_secret, nonce,\n        resource,\n        skipUserInfo,\n        extraQueryParams,\n        extraTokenParams,\n        disablePKCE,\n        ...optionalParams\n    }: SigninRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"ctor: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"ctor: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"ctor: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"ctor: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"ctor: No authority passed\");\n            throw new Error(\"authority\");\n        }\n\n        this.state = new SigninState({\n            data: state_data,\n            request_type,\n            code_verifier: !disablePKCE,\n            client_id, authority, redirect_uri,\n            response_mode,\n            client_secret, scope, extraTokenParams,\n            skipUserInfo,\n        });\n\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        parsedUrl.searchParams.append(\"scope\", scope);\n        if (nonce) {\n            parsedUrl.searchParams.append(\"nonce\", nonce);\n        }\n\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n        if (this.state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n\n        if (resource) {\n            // https://datatracker.ietf.org/doc/html/rfc8707\n            const resources = Array.isArray(resource) ? resource : [resource];\n            resources\n                .forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n        }\n\n        for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Timer } from \"./utils\";\nimport type { UserProfile } from \"./User\";\n\nconst OidcScope = \"openid\";\n\n/**\n * @public\n */\nexport class SigninResponse {\n    // props present in the initial callback response regardless of success\n    public readonly state: string | null;\n    /** @see {@link User.session_state} */\n    public session_state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public readonly error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public readonly error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public readonly error_uri: string | null;\n\n    // success props\n    public readonly code: string | null;\n\n    // props set after validation\n    /** @see {@link User.id_token} */\n    public id_token?: string;\n    /** @see {@link User.access_token} */\n    public access_token = \"\";\n    /** @see {@link User.token_type} */\n    public token_type = \"\";\n    /** @see {@link User.refresh_token} */\n    public refresh_token?: string;\n    /** @see {@link User.scope} */\n    public scope?: string;\n    /** @see {@link User.expires_at} */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n\n    /** @see {@link User.profile} */\n    public profile: UserProfile = {} as UserProfile;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n\n        this.code = params.get(\"code\");\n    }\n\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n    public set expires_in(value: number | undefined) {\n        // spec expects a number, but normalize here just in case\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== undefined && value >= 0) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    public get isOpenId(): boolean {\n        return this.scope?.split(\" \").includes(OidcScope) || !!this.id_token;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n */\nexport interface SignoutRequestArgs {\n    // mandatory\n    url: string;\n\n    // optional\n    state_data?: unknown;\n    id_token_hint?: string;\n    post_logout_redirect_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n    request_type?: string;\n}\n\n/**\n * @public\n */\nexport class SignoutRequest {\n    private readonly _logger = new Logger(\"SignoutRequest\");\n\n    public readonly url: string;\n    public readonly state?: State;\n\n    public constructor({\n        url,\n        state_data, id_token_hint, post_logout_redirect_uri, extraQueryParams, request_type,\n    }: SignoutRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n\n        const parsedUrl = new URL(url);\n        if (id_token_hint) {\n            parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        }\n\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n            if (state_data) {\n                this.state = new State({ data: state_data, request_type });\n\n                parsedUrl.searchParams.append(\"state\", this.state.id);\n            }\n        }\n\n        for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @public\n */\nexport class SignoutResponse {\n    public readonly state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, UrlUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport { ResponseValidator } from \"./ResponseValidator\";\nimport { MetadataService } from \"./MetadataService\";\nimport type { RefreshState } from \"./RefreshState\";\nimport { SigninRequest } from \"./SigninRequest\";\nimport { SigninResponse } from \"./SigninResponse\";\nimport { SignoutRequest, SignoutRequestArgs } from \"./SignoutRequest\";\nimport { SignoutResponse } from \"./SignoutResponse\";\nimport { SigninState } from \"./SigninState\";\nimport { State } from \"./State\";\nimport { TokenClient } from \"./TokenClient\";\n\n/**\n * @public\n */\nexport interface CreateSigninRequestArgs {\n    redirect_uri?: string;\n    response_type?: string;\n    scope?: string;\n    nonce?: string;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n\n    prompt?: string;\n    display?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n    resource?: string | string[];\n    response_mode?: \"query\" | \"fragment\";\n    request?: string;\n    request_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n    request_type?: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    skipUserInfo?: boolean;\n}\n\n/**\n * @public\n */\nexport interface UseRefreshTokenArgs {\n    state: RefreshState;\n    timeoutInSeconds?: number;\n}\n\n/**\n * @public\n */\nexport type CreateSignoutRequestArgs = Omit<SignoutRequestArgs, \"url\" | \"state_data\"> & { state?: unknown };\n\n/**\n * @public\n */\nexport type ProcessResourceOwnerPasswordCredentialsArgs = {\n    username: string;\n    password: string;\n    skipUserInfo?: boolean;\n    extraTokenParams?: Record<string, unknown>;\n};\n\n/**\n * Provides the raw OIDC/OAuth2 protocol support for the authorization endpoint and the end session endpoint in the\n * authorization server. It provides a bare-bones protocol implementation and is used by the UserManager class.\n * Only use this class if you simply want protocol support without the additional management features of the\n * UserManager class.\n *\n * @public\n */\nexport class OidcClient {\n    public readonly settings: OidcClientSettingsStore;\n    protected readonly _logger = new Logger(\"OidcClient\");\n\n    public readonly metadataService: MetadataService;\n    protected readonly _validator: ResponseValidator;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(settings: OidcClientSettings) {\n        this.settings = new OidcClientSettingsStore(settings);\n\n        this.metadataService = new MetadataService(this.settings);\n        this._validator = new ResponseValidator(this.settings, this.metadataService);\n        this._tokenClient = new TokenClient(this.settings, this.metadataService);\n    }\n\n    public async createSigninRequest({\n        state,\n        request,\n        request_uri,\n        request_type,\n        id_token_hint,\n        login_hint,\n        skipUserInfo,\n        nonce,\n        response_type = this.settings.response_type,\n        scope = this.settings.scope,\n        redirect_uri = this.settings.redirect_uri,\n        prompt = this.settings.prompt,\n        display = this.settings.display,\n        max_age = this.settings.max_age,\n        ui_locales = this.settings.ui_locales,\n        acr_values = this.settings.acr_values,\n        resource = this.settings.resource,\n        response_mode = this.settings.response_mode,\n        extraQueryParams = this.settings.extraQueryParams,\n        extraTokenParams = this.settings.extraTokenParams,\n    }: CreateSigninRequestArgs): Promise<SigninRequest> {\n        const logger = this._logger.create(\"createSigninRequest\");\n\n        if (response_type !== \"code\") {\n            throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        }\n\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger.debug(\"Received authorization endpoint\", url);\n\n        const signinRequest = new SigninRequest({\n            url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri,\n            response_type,\n            scope,\n            state_data: state,\n            prompt, display, max_age, ui_locales, id_token_hint, login_hint, acr_values,\n            resource, request, request_uri, extraQueryParams, extraTokenParams, request_type, response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo,\n            nonce,\n            disablePKCE: this.settings.disablePKCE,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n\n    public async readSigninResponseState(url: string, removeState = false): Promise<{ state: SigninState; response: SigninResponse }> {\n        const logger = this._logger.create(\"readSigninResponseState\");\n\n        const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.throw(new Error(\"No state in response\"));\n            // need to throw within this function's body for type narrowing to work\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = SigninState.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSigninResponse(url: string): Promise<SigninResponse> {\n        const logger = this._logger.create(\"processSigninResponse\");\n\n        const { state, response } = await this.readSigninResponseState(url, true);\n        logger.debug(\"received state from storage; validating response\");\n        await this._validator.validateSigninResponse(response, state);\n        return response;\n    }\n\n    public async processResourceOwnerPasswordCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n        extraTokenParams = {},\n    }: ProcessResourceOwnerPasswordCredentialsArgs): Promise<SigninResponse> {\n        const tokenResponse: Record<string, unknown> = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n        const signinResponse: SigninResponse = new SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n\n    public async useRefreshToken({\n        state,\n        timeoutInSeconds,\n    }: UseRefreshTokenArgs): Promise<SigninResponse> {\n        const logger = this._logger.create(\"useRefreshToken\");\n\n        // https://github.com/authts/oidc-client-ts/issues/695\n        // In some cases (e.g. AzureAD), not all granted scopes are allowed on token refresh requests.\n        // Therefore, we filter all granted scopes by a list of allowable scopes.\n        let scope;\n        if (this.settings.refreshTokenAllowedScope === undefined) {\n            scope = state.scope;\n        } else {\n            const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n            const providedScopes = state.scope?.split(\" \") || [];\n\n            scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n        }\n\n        const result = await this._tokenClient.exchangeRefreshToken({\n            refresh_token: state.refresh_token,\n            // provide the (possible filtered) scope list\n            scope,\n            timeoutInSeconds,\n        });\n        const response = new SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, {\n            ...state,\n            // overide the scope in the state handed over to the validator\n            // so it can set the granted scope to the requested scope in case none is included in the response\n            scope,\n        });\n        return response;\n    }\n\n    public async createSignoutRequest({\n        state,\n        id_token_hint,\n        request_type,\n        post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n        extraQueryParams = this.settings.extraQueryParams,\n    }: CreateSignoutRequestArgs = {}): Promise<SignoutRequest> {\n        const logger = this._logger.create(\"createSignoutRequest\");\n\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger.throw(new Error(\"No end session endpoint\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"Received end session endpoint\", url);\n\n        const request = new SignoutRequest({\n            url,\n            id_token_hint,\n            post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams,\n            request_type,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signoutState = request.state;\n        if (signoutState) {\n            logger.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n\n        return request;\n    }\n\n    public async readSignoutResponseState(url: string, removeState = false): Promise<{ state: State | undefined; response: SignoutResponse }> {\n        const logger = this._logger.create(\"readSignoutResponseState\");\n\n        const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.debug(\"No state in response\");\n\n            if (response.error) {\n                logger.warn(\"Response was error:\", response.error);\n                throw new ErrorResponse(response);\n            }\n\n            return { state: undefined, response };\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = State.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSignoutResponse(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"processSignoutResponse\");\n\n        const { state, response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else {\n            logger.debug(\"No state from storage; skipping response validation\");\n        }\n\n        return response;\n    }\n\n    public clearStaleState(): Promise<void> {\n        this._logger.create(\"clearStaleState\");\n        return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n\n    public async revokeToken(token: string, type?: \"access_token\" | \"refresh_token\"): Promise<void> {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token,\n            token_type_hint: type,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nimport type { UserManager } from \"./UserManager\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport class SessionMonitor {\n    private readonly _logger = new Logger(\"SessionMonitor\");\n\n    private _sub: string | undefined;\n    private _sid: string | undefined;\n    private _checkSessionIFrame?: CheckSessionIFrame;\n\n    public constructor(private readonly _userManager: UserManager) {\n        if (!_userManager) {\n            this._logger.throw(new Error(\"No user manager passed\"));\n        }\n\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n\n        this._init().catch((err: unknown) => {\n            // catch to suppress errors since we're in a ctor\n            this._logger.error(err);\n        });\n    }\n\n    protected async _init(): Promise<void> {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        // doing this manually here since calling getUser\n        // doesn't trigger load event.\n        if (user) {\n            void this._start(user);\n        }\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub && session.sid ? {\n                        sub: session.sub,\n                        sid: session.sid,\n                    } : null,\n                };\n                void this._start(tmpUser);\n            }\n        }\n    }\n\n    protected _start = async (\n        user: User | {\n            session_state: string;\n            profile: { sub: string; sid: string } | null;\n        },\n    ): Promise<void> => {\n        const session_state = user.session_state;\n        if (!session_state) {\n            return;\n        }\n        const logger = this._logger.create(\"_start\");\n\n        if (user.profile) {\n            this._sub = user.profile.sub;\n            this._sid = user.profile.sid;\n            logger.debug(\"session_state\", session_state, \", sub\", this._sub);\n        }\n        else {\n            this._sub = undefined;\n            this._sid = undefined;\n            logger.debug(\"session_state\", session_state, \", anonymous user\");\n        }\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.start(session_state);\n            return;\n        }\n\n        try {\n            const url = await this._userManager.metadataService.getCheckSessionIframe();\n            if (url) {\n                logger.debug(\"initializing check session iframe\");\n\n                const client_id = this._userManager.settings.client_id;\n                const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n\n                const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                await checkSessionIFrame.load();\n                this._checkSessionIFrame = checkSessionIFrame;\n                checkSessionIFrame.start(session_state);\n            }\n            else {\n                logger.warn(\"no check session iframe found in the metadata\");\n            }\n        }\n        catch (err) {\n            // catch to suppress errors since we're in non-promise callback\n            logger.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n        }\n    };\n\n    protected _stop = (): void => {\n        const logger = this._logger.create(\"_stop\");\n        this._sub = undefined;\n        this._sid = undefined;\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.stop();\n        }\n\n        if (this._userManager.settings.monitorAnonymousSession) {\n            // using a timer to delay re-initialization to avoid race conditions during signout\n            // TODO rewrite to use promise correctly\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            const timerHandle = setInterval(async () => {\n                clearInterval(timerHandle);\n\n                try {\n                    const session = await this._userManager.querySessionStatus();\n                    if (session) {\n                        const tmpUser = {\n                            session_state: session.session_state,\n                            profile: session.sub && session.sid ? {\n                                sub: session.sub,\n                                sid: session.sid,\n                            } : null,\n                        };\n                        void this._start(tmpUser);\n                    }\n                }\n                catch (err) {\n                    // catch to suppress errors since we're in a callback\n                    logger.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                }\n            }, 1000);\n        }\n    };\n\n    protected _callback = async (): Promise<void> => {\n        const logger = this._logger.create(\"_callback\");\n        try {\n            const session = await this._userManager.querySessionStatus();\n            let raiseEvent = true;\n\n            if (session && this._checkSessionIFrame) {\n                if (session.sub === this._sub) {\n                    raiseEvent = false;\n                    this._checkSessionIFrame.start(session.session_state);\n\n                    if (session.sid === this._sid) {\n                        logger.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n                    }\n                    else {\n                        logger.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                        this._userManager.events._raiseUserSessionChanged();\n                    }\n                }\n                else {\n                    logger.debug(\"different subject signed into OP\", session.sub);\n                }\n            }\n            else {\n                logger.debug(\"subject no longer signed into OP\");\n            }\n\n            if (raiseEvent) {\n                if (this._sub) {\n                    this._userManager.events._raiseUserSignedOut();\n                }\n                else {\n                    this._userManager.events._raiseUserSignedIn();\n                }\n            } else {\n                logger.debug(\"no change in session detected, no event to raise\");\n            }\n        }\n        catch (err) {\n            if (this._sub) {\n                logger.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                this._userManager.events._raiseUserSignedOut();\n            }\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { IdTokenClaims } from \"./Claims\";\n\n/**\n * Holds claims represented by a combination of the `id_token` and the user info endpoint.\n * @public\n */\nexport type UserProfile = IdTokenClaims;\n\n/**\n * @public\n */\nexport class User {\n    /**\n     * A JSON Web Token (JWT). Only provided if `openid` scope was requested.\n     * The application can access the data decoded by using the `profile` property.\n     */\n    public id_token?: string;\n\n    /** The session state value returned from the OIDC provider. */\n    public session_state: string | null;\n\n    /**\n     * The requested access token returned from the OIDC provider. The application can use this token to\n     * authenticate itself to the secured resource.\n     */\n    public access_token: string;\n\n    /**\n     * An OAuth 2.0 refresh token. The app can use this token to acquire additional access tokens after the\n     * current access token expires. Refresh tokens are long-lived and can be used to maintain access to resources\n     * for extended periods of time.\n     */\n    public refresh_token?: string;\n\n    /** Typically \"Bearer\" */\n    public token_type: string;\n\n    /** The scopes that the requested access token is valid for. */\n    public scope?: string;\n\n    /** The claims represented by a combination of the `id_token` and the user info endpoint. */\n    public profile: UserProfile;\n\n    /** The expires at returned from the OIDC provider. */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public readonly state: unknown;\n\n    public constructor(args: {\n        id_token?: string;\n        session_state?: string | null;\n        access_token: string;\n        refresh_token?: string;\n        token_type: string;\n        scope?: string;\n        profile: UserProfile;\n        expires_at?: number;\n        userState?: unknown;\n    }) {\n        this.id_token = args.id_token;\n        this.session_state = args.session_state ?? null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n    }\n\n    /** Computed number of seconds the access token has remaining. */\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n\n    public set expires_in(value: number | undefined) {\n        if (value !== undefined) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    /** Computed value indicating if the access token is expired. */\n    public get expired(): boolean | undefined {\n        const expires_in = this.expires_in;\n        if (expires_in === undefined) {\n            return undefined;\n        }\n        return expires_in <= 0;\n    }\n\n    /** Array representing the parsed values from the `scope`. */\n    public get scopes(): string[] {\n        return this.scope?.split(\" \") ?? [];\n    }\n\n    public toStorageString(): string {\n        new Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at,\n        });\n    }\n\n    public static fromStorageString(storageString: string): User {\n        Logger.createStatic(\"User\", \"fromStorageString\");\n        return new User(JSON.parse(storageString));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event, Logger, UrlUtils } from \"../utils\";\nimport type { IWindow, NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst messageSource = \"oidc-client\";\n\ninterface MessageData {\n    source: string;\n    url: string;\n    keepOpen: boolean;\n}\n\n/**\n * Window implementation which resolves via communication from a child window\n * via the `Window.postMessage()` interface.\n *\n * @internal\n */\nexport abstract class AbstractChildWindow implements IWindow {\n    protected abstract readonly _logger: Logger;\n    protected readonly _abort = new Event<[reason: Error]>(\"Window navigation aborted\");\n    protected readonly _disposeHandlers = new Set<() => void>();\n\n    protected _window: WindowProxy | null = null;\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"navigate\");\n        if (!this._window) {\n            throw new Error(\"Attempted to navigate on a disposed window\");\n        }\n\n        logger.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n\n        const { url, keepOpen } = await new Promise<MessageData>((resolve, reject) => {\n            const listener = (e: MessageEvent) => {\n                const data: MessageData | undefined = e.data;\n                const origin = params.scriptOrigin ?? window.location.origin;\n                if (e.origin !== origin || data?.source !== messageSource) {\n                    // silently discard events not intended for us\n                    return;\n                }\n                try {\n                    const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) {\n                        logger.warn(\"no state found in response url\");\n                    }\n                    if (e.source !== this._window && state !== params.state) {\n                        // MessageEvent source is a relatively modern feature, we can't rely on it\n                        // so we also inspect the payload for a matching state key as an alternative\n                        return;\n                    }\n                }\n                catch (err) {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n            this._disposeHandlers.add(this._abort.addHandler((reason) => {\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger.debug(\"got response from window\");\n        this._dispose();\n\n        if (!keepOpen) {\n            this.close();\n        }\n\n        return { url };\n    }\n\n    public abstract close(): void;\n\n    private _dispose(): void {\n        this._logger.create(\"_dispose\");\n\n        for (const dispose of this._disposeHandlers) {\n            dispose();\n        }\n        this._disposeHandlers.clear();\n    }\n\n    protected static _notifyParent(parent: Window, url: string, keepOpen = false, targetOrigin = window.location.origin): void {\n        parent.postMessage({\n            source: messageSource,\n            url,\n            keepOpen,\n        } as MessageData, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { PopupWindowFeatures } from \"./utils/PopupUtils\";\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\n\nexport const DefaultPopupWindowFeatures: PopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n};\nexport const DefaultPopupTarget = \"_blank\";\nconst DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nconst DefaultCheckSessionIntervalInSeconds = 2;\nexport const DefaultSilentRequestTimeoutInSeconds = 10;\n\n/**\n * The settings used to configure the {@link UserManager}.\n *\n * @public\n */\nexport interface UserManagerSettings extends OidcClientSettings {\n    /** The URL for the page containing the call to signinPopupCallback to handle the callback from the OIDC/OAuth2 */\n    popup_redirect_uri?: string;\n    popup_post_logout_redirect_uri?: string;\n    /**\n     * The features parameter to window.open for the popup signin window. By default, the popup is\n     * placed centered in front of the window opener.\n     * (default: \\{ location: false, menubar: false, height: 640 \\})\n     */\n    popupWindowFeatures?: PopupWindowFeatures;\n    /** The target parameter to window.open for the popup signin window (default: \"_blank\") */\n    popupWindowTarget?: string;\n    /** The methods window.location method used to redirect (default: \"assign\") */\n    redirectMethod?: \"replace\" | \"assign\";\n    /** The methods target window being redirected (default: \"self\") */\n    redirectTarget?: \"top\" | \"self\";\n\n    /** The target to pass while calling postMessage inside iframe for callback (default: window.location.origin) */\n    iframeNotifyParentOrigin?: string;\n\n    /** The script origin to check during 'message' callback execution while performing silent auth via iframe (default: window.location.origin) */\n    iframeScriptOrigin?: string;\n\n    /** The URL for the page containing the code handling the silent renew */\n    silent_redirect_uri?: string;\n    /** Number of seconds to wait for the silent renew to return before assuming it has failed or timed out (default: 10) */\n    silentRequestTimeoutInSeconds?: number;\n    /** Flag to indicate if there should be an automatic attempt to renew the access token prior to its expiration (default: true) */\n    automaticSilentRenew?: boolean;\n    /** Flag to validate user.profile.sub in silent renew calls (default: true) */\n    validateSubOnSilentRenew?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent renew calls (default: false) */\n    includeIdTokenInSilentRenew?: boolean;\n\n    /** Will raise events for when user has performed a signout at the OP (default: false) */\n    monitorSession?: boolean;\n    monitorAnonymousSession?: boolean;\n    /** Interval in seconds to check the user's session (default: 2) */\n    checkSessionIntervalInSeconds?: number;\n    query_status_response_type?: string;\n    stopCheckSessionOnError?: boolean;\n\n    /**\n     * The `token_type_hint`s to pass to the authority server by default (default: [\"access_token\", \"refresh_token\"])\n     *\n     * Token types will be revoked in the same order as they are given here.\n     */\n    revokeTokenTypes?: (\"access_token\" | \"refresh_token\")[];\n    /** Will invoke the revocation endpoint on signout if there is an access token for the user (default: false) */\n    revokeTokensOnSignout?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent signout calls (default: false) */\n    includeIdTokenInSilentSignout?: boolean;\n\n    /** The number of seconds before an access token is to expire to raise the accessTokenExpiring event (default: 60) */\n    accessTokenExpiringNotificationTimeInSeconds?: number;\n\n    /**\n     * Storage object used to persist User for currently authenticated user (default: window.sessionStorage, InMemoryWebStorage iff no window).\n     *  E.g. `userStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    userStore?: WebStorageStateStore;\n}\n\n/**\n * The settings with defaults applied of the {@link UserManager}.\n * @see {@link UserManagerSettings}\n *\n * @public\n */\nexport class UserManagerSettingsStore extends OidcClientSettingsStore {\n    public readonly popup_redirect_uri: string;\n    public readonly popup_post_logout_redirect_uri: string | undefined;\n    public readonly popupWindowFeatures: PopupWindowFeatures;\n    public readonly popupWindowTarget: string;\n    public readonly redirectMethod: \"replace\" | \"assign\";\n    public readonly redirectTarget: \"top\" | \"self\";\n\n    public readonly iframeNotifyParentOrigin: string | undefined;\n    public readonly iframeScriptOrigin: string | undefined;\n\n    public readonly silent_redirect_uri: string;\n    public readonly silentRequestTimeoutInSeconds: number;\n    public readonly automaticSilentRenew: boolean;\n    public readonly validateSubOnSilentRenew: boolean;\n    public readonly includeIdTokenInSilentRenew: boolean;\n\n    public readonly monitorSession: boolean;\n    public readonly monitorAnonymousSession: boolean;\n    public readonly checkSessionIntervalInSeconds: number;\n    public readonly query_status_response_type: string;\n    public readonly stopCheckSessionOnError: boolean;\n\n    public readonly revokeTokenTypes: (\"access_token\" | \"refresh_token\")[];\n    public readonly revokeTokensOnSignout: boolean;\n    public readonly includeIdTokenInSilentSignout: boolean;\n\n    public readonly accessTokenExpiringNotificationTimeInSeconds: number;\n\n    public readonly userStore: WebStorageStateStore;\n\n    public constructor(args: UserManagerSettings) {\n        const {\n            popup_redirect_uri = args.redirect_uri,\n            popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n            popupWindowFeatures = DefaultPopupWindowFeatures,\n            popupWindowTarget = DefaultPopupTarget,\n            redirectMethod = \"assign\",\n            redirectTarget = \"self\",\n\n            iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n            iframeScriptOrigin = args.iframeScriptOrigin,\n\n            silent_redirect_uri = args.redirect_uri,\n            silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n            automaticSilentRenew = true,\n            validateSubOnSilentRenew = true,\n            includeIdTokenInSilentRenew = false,\n\n            monitorSession = false,\n            monitorAnonymousSession = false,\n            checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n            query_status_response_type = \"code\",\n            stopCheckSessionOnError = true,\n\n            revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n            revokeTokensOnSignout = false,\n            includeIdTokenInSilentSignout = false,\n\n            accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n\n            userStore,\n        } = args;\n\n        super(args);\n\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n        if (userStore) {\n            this.userStore = userStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n            this.userStore = new WebStorageStateStore({ store });\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { ErrorTimeout } from \"../errors\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport { DefaultSilentRequestTimeoutInSeconds } from \"../UserManagerSettings\";\n\n/**\n * @public\n */\nexport interface IFrameWindowParams {\n    silentRequestTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport class IFrameWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"IFrameWindow\");\n    private _frame: HTMLIFrameElement | null;\n    private _timeoutInSeconds: number;\n\n    public constructor({\n        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n    }: IFrameWindowParams) {\n        super();\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n\n        this._frame = IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n\n    private static createHiddenIframe(): HTMLIFrameElement {\n        const iframe = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n        iframe.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1000);\n        this._disposeHandlers.add(() => clearTimeout(timer));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev) => {\n                    const frame = ev.target as HTMLIFrameElement;\n                    frame.parentNode?.removeChild(frame);\n                    this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                this._frame.contentWindow?.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n\n    public static notifyParent(url: string, targetOrigin?: string): void {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport { IFrameWindow, IFrameWindowParams } from \"./IFrameWindow\";\nimport type { INavigator } from \"./INavigator\";\n\n/**\n * @internal\n */\nexport class IFrameNavigator implements INavigator {\n    private readonly _logger = new Logger(\"IFrameNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds,\n    }: IFrameWindowParams): Promise<IFrameWindow> {\n        return new IFrameWindow({ silentRequestTimeoutInSeconds });\n    }\n\n    public async callback(url: string): Promise<void> {\n        this._logger.create(\"callback\");\n        IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, PopupUtils, PopupWindowFeatures } from \"../utils\";\nimport { DefaultPopupWindowFeatures, DefaultPopupTarget } from \"../UserManagerSettings\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst checkForPopupClosedInterval = 500;\n\n/**\n * @public\n */\nexport interface PopupWindowParams {\n    popupWindowFeatures?: PopupWindowFeatures;\n    popupWindowTarget?: string;\n}\n\n/**\n * @internal\n */\nexport class PopupWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"PopupWindow\");\n\n    protected _window: WindowProxy | null;\n\n    public constructor({\n        popupWindowTarget = DefaultPopupTarget,\n        popupWindowFeatures = {},\n    }: PopupWindowParams) {\n        super();\n        const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n        this._window = window.open(undefined, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._window?.focus();\n\n        const popupClosedInterval = setInterval(() => {\n            if (!this._window || this._window.closed) {\n                this._abort.raise(new Error(\"Popup closed by user\"));\n            }\n        }, checkForPopupClosedInterval);\n        this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n\n    public static notifyOpener(url: string, keepOpen: boolean): void {\n        if (!window.opener) {\n            throw new Error(\"No window.opener. Can't complete notification.\");\n        }\n        return super._notifyParent(window.opener, url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { PopupWindow, PopupWindowParams } from \"./PopupWindow\";\nimport type { INavigator } from \"./INavigator\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\n\n/**\n * @internal\n */\nexport class PopupNavigator implements INavigator {\n    private readonly _logger = new Logger(\"PopupNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        popupWindowFeatures = this._settings.popupWindowFeatures,\n        popupWindowTarget = this._settings.popupWindowTarget,\n    }: PopupWindowParams): Promise<PopupWindow> {\n        return new PopupWindow({ popupWindowFeatures, popupWindowTarget });\n    }\n\n    public async callback(url: string, keepOpen = false): Promise<void> {\n        this._logger.create(\"callback\");\n\n        PopupWindow.notifyOpener(url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport type { INavigator } from \"./INavigator\";\nimport type { IWindow } from \"./IWindow\";\n\n/**\n * @public\n */\nexport interface RedirectParams {\n    redirectMethod?: \"replace\" | \"assign\";\n    redirectTarget?: \"top\" | \"self\";\n}\n\n/**\n * @internal\n */\nexport class RedirectNavigator implements INavigator {\n    private readonly _logger = new Logger(\"RedirectNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        redirectMethod = this._settings.redirectMethod,\n        redirectTarget = this._settings.redirectTarget,\n    }: RedirectParams): Promise<IWindow> {\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self as Window;\n\n        if (redirectTarget === \"top\") {\n            targetWindow = window.top ?? window.self;\n        }\n    \n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location) as (url: string) => never;\n        let abort: (reason: Error) => void;\n        return {\n            navigate: async (params): Promise<never> => {\n                this._logger.create(\"navigate\");\n                // We use a promise that never resolves to block the caller\n                const promise = new Promise((resolve, reject) => {\n                    abort = reject;\n                });\n                redirect(params.url);\n                return await (promise as Promise<never>);\n            },\n            close: () => {\n                this._logger.create(\"close\");\n                abort?.(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            },\n        };\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Event } from \"./utils\";\nimport { AccessTokenEvents } from \"./AccessTokenEvents\";\nimport type { UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type UserLoadedCallback = (user: User) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserUnloadedCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type SilentRenewErrorCallback = (error: Error) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedInCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedOutCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSessionChangedCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport class UserManagerEvents extends AccessTokenEvents {\n    protected readonly _logger = new Logger(\"UserManagerEvents\");\n\n    private readonly _userLoaded = new Event<[User]>(\"User loaded\");\n    private readonly _userUnloaded = new Event<[]>(\"User unloaded\");\n    private readonly _silentRenewError = new Event<[Error]>(\"Silent renew error\");\n    private readonly _userSignedIn = new Event<[]>(\"User signed in\");\n    private readonly _userSignedOut = new Event<[]>(\"User signed out\");\n    private readonly _userSessionChanged = new Event<[]>(\"User session changed\");\n\n    public constructor(settings: UserManagerSettingsStore) {\n        super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    }\n\n    public load(user: User, raiseEvent=true): void {\n        super.load(user);\n        if (raiseEvent) {\n            this._userLoaded.raise(user);\n        }\n    }\n    public unload(): void {\n        super.unload();\n        this._userUnloaded.raise();\n    }\n\n    /**\n     * Add callback: Raised when a user session has been established (or re-established).\n     */\n    public addUserLoaded(cb: UserLoadedCallback): () => void {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been established (or re-established).\n     */\n    public removeUserLoaded(cb: UserLoadedCallback): void {\n        return this._userLoaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when a user session has been terminated.\n     */\n    public addUserUnloaded(cb: UserUnloadedCallback): () => void {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been terminated.\n     */\n    public removeUserUnloaded(cb: UserUnloadedCallback): void {\n        return this._userUnloaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when the automatic silent renew has failed.\n     */\n    public addSilentRenewError(cb: SilentRenewErrorCallback): () => void {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the automatic silent renew has failed.\n     */\n    public removeSilentRenewError(cb: SilentRenewErrorCallback): void {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseSilentRenewError(e: Error): void {\n        this._silentRenewError.raise(e);\n    }\n\n    /**\n     * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedIn(cb: UserSignedInCallback): () => void {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n     */\n    public removeUserSignedIn(cb: UserSignedInCallback): void {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSignedIn(): void {\n        this._userSignedIn.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedOut(cb: UserSignedOutCallback): () => void {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     */\n    public removeUserSignedOut(cb: UserSignedOutCallback): void {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSignedOut(): void {\n        this._userSignedOut.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user session changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSessionChanged(cb: UserSessionChangedCallback): () => void {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n     */\n    public removeUserSessionChanged(cb: UserSessionChangedCallback): void {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSessionChanged(): void {\n        this._userSessionChanged.raise();\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport { ErrorTimeout } from \"./errors\";\nimport type { UserManager } from \"./UserManager\";\nimport type { AccessTokenCallback } from \"./AccessTokenEvents\";\n\n/**\n * @internal\n */\nexport class SilentRenewService {\n    protected _logger = new Logger(\"SilentRenewService\");\n    private _isStarted = false;\n    private readonly _retryTimer = new Timer(\"Retry Silent Renew\");\n\n    public constructor(private _userManager: UserManager) {}\n\n    public async start(): Promise<void> {\n        const logger = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n\n            // this will trigger loading of the user so the expiring events can be initialized\n            try {\n                await this._userManager.getUser();\n                // deliberate nop\n            }\n            catch (err) {\n                // catch to suppress errors since we're in a ctor\n                logger.error(\"getUser error\", err);\n            }\n        }\n    }\n\n    public stop(): void {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n\n    protected _tokenExpiring: AccessTokenCallback = async () => {\n        const logger = this._logger.create(\"_tokenExpiring\");\n        try {\n            await this._userManager.signinSilent();\n            logger.debug(\"silent token renewal successful\");\n        }\n        catch (err) {\n            if (err instanceof ErrorTimeout) {\n                // no response from authority server, e.g. IFrame timeout, ...\n                logger.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                this._retryTimer.init(5);\n                return;\n            }\n\n            logger.error(\"Error from signinSilent:\", err);\n            this._userManager.events._raiseSilentRenewError(err as Error);\n        }\n    };\n}\n","// Copyright (C) AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { UserProfile } from \"./User\";\n\n/**\n * Fake state store implementation necessary for validating refresh token requests.\n *\n * @internal\n */\nexport class RefreshState {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data: unknown | undefined;\n\n    public readonly refresh_token: string;\n    public readonly id_token?: string;\n    public readonly session_state: string | null;\n    public readonly scope?: string;\n    public readonly profile: UserProfile;\n\n    constructor(args: {\n        refresh_token: string;\n        id_token?: string;\n        session_state: string | null;\n        scope?: string;\n        profile: UserProfile;\n\n        state?: unknown;\n    }) {\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n\n        this.data = args.state;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { IFrameNavigator, NavigateResponse, PopupNavigator, RedirectNavigator, PopupWindowParams,\n    IWindow, IFrameWindowParams, RedirectParams } from \"./navigators\";\nimport { OidcClient, CreateSigninRequestArgs, CreateSignoutRequestArgs, ProcessResourceOwnerPasswordCredentialsArgs } from \"./OidcClient\";\nimport { UserManagerSettings, UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport { User } from \"./User\";\nimport { UserManagerEvents } from \"./UserManagerEvents\";\nimport { SilentRenewService } from \"./SilentRenewService\";\nimport { SessionMonitor } from \"./SessionMonitor\";\nimport type { SessionStatus } from \"./SessionStatus\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { RefreshState } from \"./RefreshState\";\nimport type { SigninResponse } from \"./SigninResponse\";\n\n/**\n * @public\n */\nexport type ExtraSigninRequestArgs = Pick<CreateSigninRequestArgs, \"nonce\" | \"extraQueryParams\" | \"extraTokenParams\" | \"state\" | \"redirect_uri\" | \"prompt\" | \"acr_values\" | \"login_hint\" | \"scope\" >;\n/**\n * @public\n */\nexport type ExtraSignoutRequestArgs = Pick<CreateSignoutRequestArgs, \"extraQueryParams\" | \"state\" | \"id_token_hint\" | \"post_logout_redirect_uri\">;\n\n/**\n * @public\n */\nexport type RevokeTokensTypes = UserManagerSettings[\"revokeTokenTypes\"];\n\n/**\n * @public\n */\nexport type SigninRedirectArgs = RedirectParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninPopupArgs = PopupWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninSilentArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninResourceOwnerCredentialsArgs = ProcessResourceOwnerPasswordCredentialsArgs;\n\n/**\n * @public\n */\nexport type QuerySessionStatusArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutRedirectArgs = RedirectParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutPopupArgs = PopupWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutSilentArgs = IFrameWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * Provides a higher level API for signing a user in, signing out, managing the user's claims returned from the OIDC provider,\n * and managing an access token returned from the OIDC/OAuth2 provider.\n *\n * @public\n */\nexport class UserManager {\n    /** Returns the settings used to configure the `UserManager`. */\n    public readonly settings: UserManagerSettingsStore;\n    protected readonly _logger = new Logger(\"UserManager\");\n\n    protected readonly _client: OidcClient;\n    protected readonly _redirectNavigator: RedirectNavigator;\n    protected readonly _popupNavigator: PopupNavigator;\n    protected readonly _iframeNavigator: IFrameNavigator;\n    protected readonly _events: UserManagerEvents;\n    protected readonly _silentRenewService: SilentRenewService;\n    protected readonly _sessionMonitor: SessionMonitor | null;\n\n    public constructor(settings: UserManagerSettings) {\n        this.settings = new UserManagerSettingsStore(settings);\n\n        this._client = new OidcClient(settings);\n\n        this._redirectNavigator = new RedirectNavigator(this.settings);\n        this._popupNavigator = new PopupNavigator(this.settings);\n        this._iframeNavigator = new IFrameNavigator(this.settings);\n\n        this._events = new UserManagerEvents(this.settings);\n        this._silentRenewService = new SilentRenewService(this);\n\n        // order is important for the following properties; these services depend upon the events.\n        if (this.settings.automaticSilentRenew) {\n            this.startSilentRenew();\n        }\n\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) {\n            this._sessionMonitor = new SessionMonitor(this);\n        }\n\n    }\n\n    /** Returns an object used to register for events raised by the `UserManager`. */\n    public get events(): UserManagerEvents {\n        return this._events;\n    }\n\n    /** Returns an object used to access the metadata configuration of the OIDC provider. */\n    public get metadataService(): MetadataService {\n        return this._client.metadataService;\n    }\n\n    /**\n     * Returns promise to load the `User` object for the currently authenticated user.\n     */\n    public async getUser(): Promise<User | null> {\n        const logger = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger.info(\"user loaded\");\n            this._events.load(user, false);\n            return user;\n        }\n\n        logger.info(\"user not found in storage\");\n        return null;\n    }\n\n    /**\n     * Returns promise to remove from any storage the currently authenticated user.\n     */\n    public async removeUser(): Promise<void> {\n        const logger = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger.info(\"user removed from storage\");\n        this._events.unload();\n    }\n\n    /**\n     * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n     */\n    public async signinRedirect(args: SigninRedirectArgs = {}): Promise<void> {\n        this._logger.create(\"signinRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signinStart({\n            request_type: \"si:r\",\n            ...requestArgs,\n        }, handle);\n    }\n\n    /**\n     * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n     */\n    public async signinRedirectCallback(url = window.location.href): Promise<User> {\n        const logger = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        }\n        else {\n            logger.info(\"no subject\");\n        }\n\n        return user;\n    }\n\n    /**\n     * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n     *\n     * Throws an ErrorResponse in case of wrong authentication.\n     */\n    public async signinResourceOwnerCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: SigninResourceOwnerCredentialsArgs ) {\n        const logger = this._logger.create(\"signinResourceOwnerCredential\");\n\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        } else {\n            logger.info(\"no subject\");\n        }\n        return user;\n    }\n\n    /**\n     * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n     */\n    public async signinPopup(args: SigninPopupArgs = {}): Promise<User> {\n        const logger = this._logger.create(\"signinPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No popup_redirect_uri configured\"));\n        }\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            ...requestArgs,\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n    /**\n     * Returns promise to notify the opening window of response from the authorization endpoint.\n     */\n    public async signinPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, keepOpen);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n     * The result of the promise is the authenticated `User`.\n     */\n    public async signinSilent(args: SigninSilentArgs = {}): Promise<User | null> {\n        const logger = this._logger.create(\"signinSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        // first determine if we have a refresh token, or need to use iframe\n        let user = await this._loadUser();\n        if (user?.refresh_token) {\n            logger.debug(\"using refresh token\");\n            const state = new RefreshState(user as Required<User>);\n            return await this._useRefreshToken(state);\n        }\n\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        let verifySub: string | undefined;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            ...requestArgs,\n        }, handle, verifySub);\n        if (user) {\n            if (user.profile?.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    protected async _useRefreshToken(state: RefreshState): Promise<User> {\n        const response = await this._client.useRefreshToken({\n            state,\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n        });\n        const user = new User({ ...state, ...response });\n\n        await this.storeUser(user);\n        this._events.load(user);\n        return user;\n    }\n\n    /**\n     * Returns promise to notify the parent window of response from the authorization endpoint.\n     */\n    public async signinSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async signinCallback(url = window.location.href): Promise<User | void> {\n        const { state } = await this._client.readSigninResponseState(url);\n        switch (state.request_type) {\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                return await this.signinPopupCallback(url);\n            case \"si:s\":\n                return await this.signinSilentCallback(url);\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n    }\n\n    public async signoutCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const { state } = await this._client.readSignoutResponseState(url);\n        if (!state) {\n            return;\n        }\n\n        switch (state.request_type) {\n            case \"so:r\":\n                await this.signoutRedirectCallback(url);\n                break;\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n    }\n\n    /**\n     * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n     */\n    public async querySessionStatus(args: QuerySessionStatusArgs = {}): Promise<SessionStatus | null> {\n        const logger = this._logger.create(\"querySessionStatus\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\", // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs,\n        }, handle);\n        try {\n            const signinResponse = await this._client.processSigninResponse(navResponse.url);\n            logger.debug(\"got signin response\");\n\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                    sid: signinResponse.profile.sid,\n                };\n            }\n\n            logger.info(\"success, user not authenticated\");\n            return null;\n        }\n        catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n                switch (err.error) {\n                    case \"login_required\":\n                    case \"consent_required\":\n                    case \"interaction_required\":\n                    case \"account_selection_required\":\n                        logger.info(\"success for anonymous user\");\n                        return {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            session_state: err.session_state!,\n                        };\n                }\n            }\n            throw err;\n        }\n    }\n\n    protected async _signin(args: CreateSigninRequestArgs, handle: IWindow, verifySub?: string): Promise<User> {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n    protected async _signinStart(args: CreateSigninRequestArgs, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signinStart\");\n\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger.debug(\"got signin request\");\n\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        }\n        catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    protected async _signinEnd(url: string, verifySub?: string): Promise<User> {\n        const logger = this._logger.create(\"_signinEnd\");\n        const signinResponse = await this._client.processSigninResponse(url);\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n\n    protected async _buildUser(signinResponse: SigninResponse, verifySub?: string) {\n        const logger = this._logger.create(\"_buildUser\");\n        const user = new User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n            }\n            logger.debug(\"current user matches user returned from signin\");\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        this._events.load(user);\n\n        return user;\n    }\n\n    /**\n     * Returns promise to trigger a redirect of the current window to the end session endpoint.\n     */\n    public async signoutRedirect(args: SignoutRedirectArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to process response from the end session endpoint.\n     */\n    public async signoutRedirectCallback(url = window.location.href): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger.info(\"success\");\n        return response;\n    }\n\n    /**\n     * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n     */\n    public async signoutPopup(args: SignoutPopupArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? undefined : {},\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to process response from the end session endpoint from a popup window.\n     */\n    public async signoutPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, keepOpen);\n        logger.info(\"success\");\n    }\n\n    protected async _signout(args: CreateSignoutRequestArgs, handle: IWindow): Promise<SignoutResponse> {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n    protected async _signoutStart(args: CreateSignoutRequestArgs = {}, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signoutStart\");\n\n        try {\n            const user = await this._loadUser();\n            logger.debug(\"loaded current user from storage\");\n\n            if (this.settings.revokeTokensOnSignout) {\n                await this._revokeInternal(user);\n            }\n\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n\n            await this.removeUser();\n            logger.debug(\"user removed, creating signout request\");\n\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger.debug(\"got signout request\");\n\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: signoutRequest.state?.id,\n            });\n        }\n        catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    protected async _signoutEnd(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger.debug(\"got signout response\");\n\n        return signoutResponse;\n    }\n\n    /**\n     * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n     */\n    public async signoutSilent(args: SignoutSilentArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout\n            ? (await this._loadUser())?.id_token\n            : undefined;\n\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs,\n        }, handle);\n\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to notify the parent window of response from the end session endpoint.\n     */\n    public async signoutSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async revokeTokens(types?: RevokeTokensTypes): Promise<void> {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n\n    protected async _revokeInternal(user: User | null, types = this.settings.revokeTokenTypes): Promise<void> {\n        const logger = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n\n        const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n        if (!typesPresent.length) {\n            logger.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n\n        // don't Promise.all, order matters\n        for (const type of typesPresent) {\n            await this._client.revokeToken(\n                user[type]!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                type,\n            );\n            logger.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") {\n                user[type] = null as never;\n            }\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        this._events.load(user);\n    }\n\n    /**\n     * Enables silent renew for the `UserManager`.\n     */\n    public startSilentRenew(): void {\n        this._logger.create(\"startSilentRenew\");\n        void this._silentRenewService.start();\n    }\n\n    /**\n     * Disables silent renew for the `UserManager`.\n     */\n    public stopSilentRenew(): void {\n        this._silentRenewService.stop();\n    }\n\n    protected get _userStoreKey(): string {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n\n    protected async _loadUser(): Promise<User | null> {\n        const logger = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger.debug(\"user storageString loaded\");\n            return User.fromStorageString(storageString);\n        }\n\n        logger.debug(\"no user storageString\");\n        return null;\n    }\n\n    public async storeUser(user: User | null): Promise<void> {\n        const logger = this._logger.create(\"storeUser\");\n        if (user) {\n            logger.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        }\n        else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n        }\n    }\n\n    /**\n     * Removes stale state entries in storage for incomplete authorize requests.\n     */\n    public async clearStaleState(): Promise<void> {\n        await this._client.clearStaleState();\n    }\n}\n","{\n  \"name\": \"oidc-client-ts\",\n  \"version\": \"2.2.2\",\n  \"description\": \"OpenID Connect (OIDC) & OAuth2 client library\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com:authts/oidc-client-ts.git\"\n  },\n  \"homepage\": \"https://github.com/authts/oidc-client-ts#readme\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/umd/oidc-client-ts.js\",\n  \"types\": \"dist/types/oidc-client-ts.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/types/oidc-client-ts.d.ts\",\n      \"import\": \"./dist/esm/oidc-client-ts.js\",\n      \"require\": \"./dist/umd/oidc-client-ts.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"authentication\",\n    \"oauth2\",\n    \"oidc\",\n    \"openid\",\n    \"OpenID Connect\"\n  ],\n  \"scripts\": {\n    \"build\": \"node scripts/build.js && npm run build-types\",\n    \"build-types\": \"tsc -p tsconfig.build.json && api-extractor run\",\n    \"clean\": \"git clean -fdX dist lib *.tsbuildinfo\",\n    \"prepack\": \"npm run build\",\n    \"test\": \"tsc && jest\",\n    \"typedoc\": \"typedoc\",\n    \"lint\": \"eslint --max-warnings=0 --cache .\",\n    \"prepare\": \"husky install\"\n  },\n  \"dependencies\": {\n    \"crypto-js\": \"^4.1.1\",\n    \"jwt-decode\": \"^3.1.2\"\n  },\n  \"devDependencies\": {\n    \"@microsoft/api-extractor\": \"^7.18.10\",\n    \"@testing-library/jest-dom\": \"^5.16.5\",\n    \"@types/crypto-js\": \"^4.0.2\",\n    \"@types/jest\": \"^29.2.3\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.8.0\",\n    \"@typescript-eslint/parser\": \"^5.8.0\",\n    \"esbuild\": \"^0.17.0\",\n    \"eslint\": \"^8.5.0\",\n    \"eslint-plugin-testing-library\": \"^5.0.1\",\n    \"http-proxy-middleware\": \"^2.0.1\",\n    \"husky\": \"^8.0.1\",\n    \"jest\": \"^29.3.1\",\n    \"jest-environment-jsdom\": \"^29.3.1\",\n    \"jest-mock\": \"^29.3.1\",\n    \"lint-staged\": \"^13.0.0\",\n    \"ts-jest\": \"^29.0.3\",\n    \"typedoc\": \"^0.23.2\",\n    \"typescript\": \"~4.8.4\",\n    \"yn\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=12.13.0\"\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": \"eslint --cache --fix\"\n  }\n}\n","// @ts-expect-error avoid enabling resolveJsonModule to keep build process simple\nimport { version } from \"../package.json\";\n\n/**\n * @public\n */\nexport const Version: string = version;\n"]},"metadata":{},"sourceType":"module"}