{"ast":null,"code":"// src/AuthContext.ts\nimport React from \"react\";\nvar AuthContext = React.createContext(void 0);\nAuthContext.displayName = \"AuthContext\"; // src/AuthProvider.tsx\n\nimport React2, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from \"react\";\nimport { UserManager } from \"oidc-client-ts\"; // src/AuthState.ts\n\nvar initialAuthState = {\n  isLoading: true,\n  isAuthenticated: false\n}; // src/reducer.ts\n\nvar reducer = (state, action) => {\n  switch (action.type) {\n    case \"INITIALISED\":\n    case \"USER_LOADED\":\n      return { ...state,\n        user: action.user,\n        isLoading: false,\n        isAuthenticated: action.user ? !action.user.expired : false,\n        error: void 0\n      };\n\n    case \"USER_UNLOADED\":\n      return { ...state,\n        user: void 0,\n        isAuthenticated: false\n      };\n\n    case \"NAVIGATOR_INIT\":\n      return { ...state,\n        isLoading: true,\n        activeNavigator: action.method\n      };\n\n    case \"NAVIGATOR_CLOSE\":\n      return { ...state,\n        isLoading: false,\n        activeNavigator: void 0\n      };\n\n    case \"ERROR\":\n      return { ...state,\n        isLoading: false,\n        error: action.error\n      };\n\n    default:\n      return { ...state,\n        isLoading: false,\n        error: new Error(`unknown type ${action[\"type\"]}`)\n      };\n  }\n}; // src/utils.ts\n\n\nvar hasAuthParams = function () {\n  let location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location;\n  let searchParams = new URLSearchParams(location.search);\n\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n\n  searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n\n  return false;\n};\n\nvar normalizeErrorFn = fallbackMessage => error => {\n  if (error instanceof Error) {\n    return error;\n  }\n\n  return new Error(fallbackMessage);\n};\n\nvar loginError = normalizeErrorFn(\"Login failed\"); // src/AuthProvider.tsx\n\nvar userManagerContextKeys = [\"clearStaleState\", \"querySessionStatus\", \"revokeTokens\", \"startSilentRenew\", \"stopSilentRenew\"];\nvar navigatorKeys = [\"signinPopup\", \"signinSilent\", \"signinRedirect\", \"signoutPopup\", \"signoutRedirect\", \"signoutSilent\"];\n\nvar unsupportedEnvironment = fnName => () => {\n  throw new Error(`UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`);\n};\n\nvar defaultUserManagerImpl = typeof window === \"undefined\" ? null : UserManager;\n\nvar AuthProvider = props => {\n  const {\n    children,\n    onSigninCallback,\n    skipSigninCallback,\n    onRemoveUser,\n    onSignoutRedirect,\n    onSignoutPopup,\n    implementation: UserManagerImpl = defaultUserManagerImpl,\n    userManager: userManagerProp,\n    ...userManagerSettings\n  } = props;\n  const [userManager] = useState(() => {\n    return userManagerProp != null ? userManagerProp : UserManagerImpl ? new UserManagerImpl(userManagerSettings) : {\n      settings: userManagerSettings\n    };\n  });\n  const [state, dispatch] = useReducer(reducer, initialAuthState);\n  const userManagerContext = useMemo(() => Object.assign({\n    settings: userManager.settings,\n    events: userManager.events\n  }, Object.fromEntries(userManagerContextKeys.map(key => {\n    var _a, _b;\n\n    return [key, (_b = (_a = userManager[key]) == null ? void 0 : _a.bind(userManager)) != null ? _b : unsupportedEnvironment(key)];\n  })), Object.fromEntries(navigatorKeys.map(key => [key, userManager[key] ? async function () {\n    dispatch({\n      type: \"NAVIGATOR_INIT\",\n      method: key\n    });\n\n    try {\n      return await userManager[key](...arguments);\n    } finally {\n      dispatch({\n        type: \"NAVIGATOR_CLOSE\"\n      });\n    }\n  } : unsupportedEnvironment(key)]))), [userManager]);\n  const didInitialize = useRef(false);\n  useEffect(() => {\n    if (!userManager || didInitialize.current) {\n      return;\n    }\n\n    didInitialize.current = true;\n    void (async () => {\n      let user = null;\n\n      try {\n        if (hasAuthParams() && !skipSigninCallback) {\n          user = await userManager.signinCallback();\n          onSigninCallback && onSigninCallback(user);\n        }\n\n        user = !user ? await userManager.getUser() : user;\n        dispatch({\n          type: \"INITIALISED\",\n          user\n        });\n      } catch (error) {\n        dispatch({\n          type: \"ERROR\",\n          error: loginError(error)\n        });\n      }\n    })();\n  }, [userManager, skipSigninCallback, onSigninCallback]);\n  useEffect(() => {\n    if (!userManager) return void 0;\n\n    const handleUserLoaded = user => {\n      dispatch({\n        type: \"USER_LOADED\",\n        user\n      });\n    };\n\n    userManager.events.addUserLoaded(handleUserLoaded);\n\n    const handleUserUnloaded = () => {\n      dispatch({\n        type: \"USER_UNLOADED\"\n      });\n    };\n\n    userManager.events.addUserUnloaded(handleUserUnloaded);\n\n    const handleSilentRenewError = error => {\n      dispatch({\n        type: \"ERROR\",\n        error\n      });\n    };\n\n    userManager.events.addSilentRenewError(handleSilentRenewError);\n    return () => {\n      userManager.events.removeUserLoaded(handleUserLoaded);\n      userManager.events.removeUserUnloaded(handleUserUnloaded);\n      userManager.events.removeSilentRenewError(handleSilentRenewError);\n    };\n  }, [userManager]);\n  const removeUser = useCallback(userManager ? () => userManager.removeUser().then(onRemoveUser) : unsupportedEnvironment(\"removeUser\"), [userManager, onRemoveUser]);\n  const signoutRedirect = useCallback(args => userManagerContext.signoutRedirect(args).then(onSignoutRedirect), [userManagerContext.signoutRedirect, onSignoutRedirect]);\n  const signoutPopup = useCallback(args => userManagerContext.signoutPopup(args).then(onSignoutPopup), [userManagerContext.signoutPopup, onSignoutPopup]);\n  const signoutSilent = useCallback(args => userManagerContext.signoutSilent(args), [userManagerContext.signoutSilent]);\n  return /* @__PURE__ */React2.createElement(AuthContext.Provider, {\n    value: { ...state,\n      ...userManagerContext,\n      removeUser,\n      signoutRedirect,\n      signoutPopup,\n      signoutSilent\n    }\n  }, children);\n}; // src/useAuth.ts\n\n\nimport React3 from \"react\";\n\nvar useAuth = () => {\n  const context = React3.useContext(AuthContext);\n\n  if (!context) {\n    throw new Error(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n  }\n\n  return context;\n}; // src/withAuth.tsx\n\n\nimport React4 from \"react\";\n\nfunction withAuth(Component) {\n  const displayName = `withAuth(${Component.displayName || Component.name})`;\n\n  const C = props => {\n    const auth = useAuth();\n    return /* @__PURE__ */React4.createElement(Component, { ...props,\n      auth\n    });\n  };\n\n  C.displayName = displayName;\n  return C;\n}\n\nexport { AuthContext, AuthProvider, hasAuthParams, useAuth, withAuth };","map":{"version":3,"mappings":"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","names":["React","AuthContext","createContext","displayName","useCallback","useEffect","useMemo","useReducer","useRef","useState","UserManager","initialAuthState","isLoading","isAuthenticated","reducer","state","action","type","user","expired","error","activeNavigator","method","Error","hasAuthParams","location","window","searchParams","URLSearchParams","search","get","hash","replace","normalizeErrorFn","fallbackMessage","loginError","userManagerContextKeys","navigatorKeys","unsupportedEnvironment","fnName","defaultUserManagerImpl","AuthProvider","props","children","onSigninCallback","skipSigninCallback","onRemoveUser","onSignoutRedirect","onSignoutPopup","implementation","UserManagerImpl","userManager","userManagerProp","userManagerSettings","settings","dispatch","userManagerContext","Object","assign","events","fromEntries","map","key","_b","bind","didInitialize","current","signinCallback","getUser","handleUserLoaded","addUserLoaded","handleUserUnloaded","addUserUnloaded","handleSilentRenewError","addSilentRenewError","removeUserLoaded","removeUserUnloaded","removeSilentRenewError","removeUser","then","signoutRedirect","args","signoutPopup","signoutSilent","Provider","value","useAuth","context","useContext","withAuth","Component","name","C","auth"],"sources":["/srv/http/gallery-frontend/node_modules/react-oidc-context/src/AuthContext.ts","/srv/http/gallery-frontend/node_modules/react-oidc-context/src/AuthProvider.tsx","/srv/http/gallery-frontend/node_modules/react-oidc-context/src/AuthState.ts","/srv/http/gallery-frontend/node_modules/react-oidc-context/src/reducer.ts","/srv/http/gallery-frontend/node_modules/react-oidc-context/src/utils.ts","/srv/http/gallery-frontend/node_modules/react-oidc-context/src/useAuth.ts","/srv/http/gallery-frontend/node_modules/react-oidc-context/src/withAuth.tsx"],"sourcesContent":["import React from \"react\";\nimport type {\n    UserManagerSettings, UserManagerEvents, User, SessionStatus,\n    SigninPopupArgs, SigninSilentArgs, SigninRedirectArgs,\n    SignoutRedirectArgs, SignoutPopupArgs, QuerySessionStatusArgs,\n    RevokeTokensTypes, SignoutSilentArgs,\n} from \"oidc-client-ts\";\n\nimport type { AuthState } from \"./AuthState\";\n\n/**\n * @public\n */\nexport interface AuthContextProps extends AuthState {\n    /**\n     * UserManager functions. See [UserManager](https://github.com/authts/oidc-client-ts) for more details.\n     */\n    readonly settings: UserManagerSettings;\n    readonly events: UserManagerEvents;\n    clearStaleState(): Promise<void>;\n    removeUser(): Promise<void>;\n    signinPopup(args?: SigninPopupArgs): Promise<User>;\n    signinSilent(args?: SigninSilentArgs): Promise<User | null>;\n    signinRedirect(args?: SigninRedirectArgs): Promise<void>;\n    signoutRedirect(args?: SignoutRedirectArgs): Promise<void>;\n    signoutPopup(args?: SignoutPopupArgs): Promise<void>;\n    signoutSilent(args?: SignoutSilentArgs): Promise<void>;\n    querySessionStatus(args?: QuerySessionStatusArgs): Promise<SessionStatus | null>;\n    revokeTokens(types?: RevokeTokensTypes): Promise<void>;\n    startSilentRenew(): void;\n    stopSilentRenew(): void;\n}\n\n/**\n * @public\n */\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(undefined);\nAuthContext.displayName = \"AuthContext\";\n","import React, {\n    useCallback,\n    useEffect,\n    useMemo,\n    useReducer,\n    useRef,\n    useState,\n} from \"react\";\nimport { UserManager, UserManagerSettings, User } from \"oidc-client-ts\";\nimport type {\n    SignoutRedirectArgs,\n    SignoutPopupArgs,\n    SignoutSilentArgs,\n} from \"oidc-client-ts\";\n\nimport { AuthContext } from \"./AuthContext\";\nimport { initialAuthState } from \"./AuthState\";\nimport { reducer } from \"./reducer\";\nimport { hasAuthParams, loginError } from \"./utils\";\n\n/**\n * @public\n */\nexport interface AuthProviderPropsBase extends UserManagerSettings {\n    /**\n     * The child nodes your Provider has wrapped\n     */\n    children?: React.ReactNode;\n\n    /**\n     * On sign in callback hook. Can be a async function.\n     * Here you can remove the code and state parameters from the url when you are redirected from the authorize page.\n     *\n     * ```jsx\n     * const onSigninCallback = (_user: User | void): void => {\n     *     window.history.replaceState(\n     *         {},\n     *         document.title,\n     *         window.location.pathname\n     *     )\n     * }\n     * ```\n     */\n    onSigninCallback?: (user: User | void) => Promise<void> | void;\n\n    /**\n     * By default, if the page url has code/state params, this provider will call automatically the userManager.signinCallback.\n     * In some cases the code might be for something else (another OAuth SDK perhaps). In these\n     * instances you can instruct the client to ignore them.\n     *\n     * ```jsx\n     * <AuthProvider\n     *   skipSigninCallback={window.location.pathname === '/stripe-oauth-callback'}\n     * >\n     * ```\n     */\n    skipSigninCallback?: boolean;\n\n    /**\n     * On remove user hook. Can be a async function.\n     * Here you can change the url after the user is removed.\n     *\n     * ```jsx\n     * const onRemoveUser = (): void => {\n     *     // go to home after logout\n     *     window.location.pathname = \"\"\n     * }\n     * ```\n     */\n    onRemoveUser?: () => Promise<void> | void;\n\n    /**\n     * @deprecated On sign out redirect hook. Can be a async function.\n     */\n    onSignoutRedirect?: () => Promise<void> | void;\n\n    /**\n     * @deprecated On sign out popup hook. Can be a async function.\n     */\n    onSignoutPopup?: () => Promise<void> | void;\n\n    /**\n     * Allow passing a custom UserManager.\n     */\n    userManager?: UserManager;\n\n    /**\n     * @deprecated Allow passing a custom UserManager implementation\n     */\n    implementation?: typeof UserManager | null;\n}\n\n/**\n * @public\n */\nexport interface AuthProviderUserManagerProps extends Omit<AuthProviderPropsBase, \"redirect_uri\" | \"client_id\" | \"authority\"> {\n    redirect_uri?: never;\n    client_id?: never;\n    authority?: never;\n}\n\n/**\n * @public\n */\nexport interface AuthProviderNoUserManagerProps extends AuthProviderPropsBase {\n    userManager?: never;\n}\n\n/**\n * @public\n */\nexport type AuthProviderProps = AuthProviderNoUserManagerProps | AuthProviderUserManagerProps;\n\nconst userManagerContextKeys = [\n    \"clearStaleState\",\n    \"querySessionStatus\",\n    \"revokeTokens\",\n    \"startSilentRenew\",\n    \"stopSilentRenew\",\n] as const;\nconst navigatorKeys = [\n    \"signinPopup\",\n    \"signinSilent\",\n    \"signinRedirect\",\n    \"signoutPopup\",\n    \"signoutRedirect\",\n    \"signoutSilent\",\n] as const;\nconst unsupportedEnvironment = (fnName: string) => () => {\n    throw new Error(\n        `UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`,\n    );\n};\nconst defaultUserManagerImpl =\n    typeof window === \"undefined\" ? null : UserManager;\n\n/**\n * Provides the AuthContext to its child components.\n * @public\n */\nexport const AuthProvider = (props: AuthProviderProps): JSX.Element => {\n    const {\n        children,\n\n        onSigninCallback,\n        skipSigninCallback,\n\n        onRemoveUser,\n        onSignoutRedirect,\n        onSignoutPopup,\n\n        implementation: UserManagerImpl = defaultUserManagerImpl,\n        userManager: userManagerProp,\n        ...userManagerSettings\n    } = props;\n\n    const [userManager] = useState(() => {\n        return userManagerProp ?? \n            (UserManagerImpl\n                ? new UserManagerImpl(userManagerSettings as UserManagerSettings)\n                : ({ settings: userManagerSettings } as UserManager));\n    });\n\n    const [state, dispatch] = useReducer(reducer, initialAuthState);\n    const userManagerContext = useMemo(\n        () =>\n            Object.assign(\n                {\n                    settings: userManager.settings,\n                    events: userManager.events,\n                },\n                Object.fromEntries(\n                    userManagerContextKeys.map((key) => [\n                        key,\n                        userManager[key]?.bind(userManager) ??\n                            unsupportedEnvironment(key),\n                    ]),\n                ) as Pick<UserManager, typeof userManagerContextKeys[number]>,\n                Object.fromEntries(\n                    navigatorKeys.map((key) => [\n                        key,\n                        userManager[key]\n                            ? async (...args: never[]) => {\n                                dispatch({\n                                    type: \"NAVIGATOR_INIT\",\n                                    method: key,\n                                });\n                                try {\n                                    return await userManager[key](...args);\n                                } finally {\n                                    dispatch({ type: \"NAVIGATOR_CLOSE\" });\n                                }\n                            }\n                            : unsupportedEnvironment(key),\n                    ]),\n                ) as Pick<UserManager, typeof navigatorKeys[number]>,\n            ),\n        [userManager],\n    );\n    const didInitialize = useRef(false);\n\n    useEffect(() => {\n        if (!userManager || didInitialize.current) {\n            return;\n        }\n        didInitialize.current = true;\n\n        void (async (): Promise<void> => {\n            let user: User | void | null = null;\n            try {\n                // check if returning back from authority server\n                if (hasAuthParams() && !skipSigninCallback) {\n                    user = await userManager.signinCallback();\n                    onSigninCallback && onSigninCallback(user);\n                }\n                user = !user ? await userManager.getUser() : user;\n                dispatch({ type: \"INITIALISED\", user });\n            } catch (error) {\n                dispatch({ type: \"ERROR\", error: loginError(error) });\n            }\n        })();\n    }, [userManager, skipSigninCallback, onSigninCallback]);\n\n    // register to userManager events\n    useEffect(() => {\n        if (!userManager) return undefined;\n        // event UserLoaded (e.g. initial load, silent renew success)\n        const handleUserLoaded = (user: User) => {\n            dispatch({ type: \"USER_LOADED\", user });\n        };\n        userManager.events.addUserLoaded(handleUserLoaded);\n\n        // event UserUnloaded (e.g. userManager.removeUser)\n        const handleUserUnloaded = () => {\n            dispatch({ type: \"USER_UNLOADED\" });\n        };\n        userManager.events.addUserUnloaded(handleUserUnloaded);\n\n        // event SilentRenewError (silent renew error)\n        const handleSilentRenewError = (error: Error) => {\n            dispatch({ type: \"ERROR\", error });\n        };\n        userManager.events.addSilentRenewError(handleSilentRenewError);\n\n        return () => {\n            userManager.events.removeUserLoaded(handleUserLoaded);\n            userManager.events.removeUserUnloaded(handleUserUnloaded);\n            userManager.events.removeSilentRenewError(handleSilentRenewError);\n        };\n    }, [userManager]);\n\n    const removeUser = useCallback(\n        userManager\n            ? () => userManager.removeUser().then(onRemoveUser)\n            : unsupportedEnvironment(\"removeUser\"),\n        [userManager, onRemoveUser],\n    );\n\n    const signoutRedirect = useCallback(\n        (args?: SignoutRedirectArgs) =>\n            userManagerContext.signoutRedirect(args).then(onSignoutRedirect),\n        [userManagerContext.signoutRedirect, onSignoutRedirect],\n    );\n\n    const signoutPopup = useCallback(\n        (args?: SignoutPopupArgs) =>\n            userManagerContext.signoutPopup(args).then(onSignoutPopup),\n        [userManagerContext.signoutPopup, onSignoutPopup],\n    );\n\n    const signoutSilent = useCallback(\n        (args?: SignoutSilentArgs) =>\n            userManagerContext.signoutSilent(args),\n        [userManagerContext.signoutSilent],\n    );\n\n    return (\n        <AuthContext.Provider\n            value={{\n                ...state,\n                ...userManagerContext,\n                removeUser,\n                signoutRedirect,\n                signoutPopup,\n                signoutSilent,\n            }}\n        >\n            {children}\n        </AuthContext.Provider>\n    );\n};\n","import type { User } from \"oidc-client-ts\";\n\n/**\n * The auth state which, when combined with the auth methods, make up the return object of the `useAuth` hook.\n *\n * @public\n */\nexport interface AuthState {\n    /**\n     * See [User](https://authts.github.io/oidc-client-ts/classes/User.html) for more details.\n     */\n    user?: User | null;\n\n    /**\n     * True when the library has been initialized and no navigator request is in progress.\n     */\n    isLoading: boolean;\n\n    /**\n     * True while the user has a valid access token.\n     */\n    isAuthenticated: boolean;\n\n    /**\n     * Tracks the status of most recent signin/signout request method.\n     */\n    activeNavigator?: \"signinRedirect\" | \"signinPopup\" | \"signinSilent\" | \"signoutRedirect\" | \"signoutPopup\" | \"signoutSilent\";\n\n    /**\n     * Was there a signin or silent renew error?\n     */\n    error?: Error;\n}\n\n/**\n * The initial auth state.\n */\nexport const initialAuthState: AuthState = {\n    isLoading: true,\n    isAuthenticated: false,\n};\n","import type { User } from \"oidc-client-ts\";\n\nimport type { AuthState } from \"./AuthState\";\n\ntype Action =\n    | { type: \"INITIALISED\" | \"USER_LOADED\"; user: User | null }\n    | { type: \"USER_UNLOADED\" }\n    | { type: \"NAVIGATOR_INIT\"; method: NonNullable<AuthState[\"activeNavigator\"]> }\n    | { type: \"NAVIGATOR_CLOSE\" }\n    | { type: \"ERROR\"; error: Error };\n\n/**\n * Handles how that state changes in the `useAuth` hook.\n */\nexport const reducer = (state: AuthState, action: Action): AuthState => {\n    switch (action.type) {\n        case \"INITIALISED\":\n        case \"USER_LOADED\":\n            return {\n                ...state,\n                user: action.user,\n                isLoading: false,\n                isAuthenticated: action.user ? !action.user.expired : false,\n                error: undefined,\n            };\n        case \"USER_UNLOADED\":\n            return {\n                ...state,\n                user: undefined,\n                isAuthenticated: false,\n            };\n        case \"NAVIGATOR_INIT\":\n            return {\n                ...state,\n                isLoading: true,\n                activeNavigator: action.method,\n            };\n        case \"NAVIGATOR_CLOSE\":\n            // we intentionally don't handle cases where multiple concurrent navigators are open\n            return {\n                ...state,\n                isLoading: false,\n                activeNavigator: undefined,\n            };\n        case \"ERROR\":\n            return {\n                ...state,\n                isLoading: false,\n                error: action.error,\n            };\n        default:\n            return {\n                ...state,\n                isLoading: false,\n                error: new Error(`unknown type ${action[\"type\"] as string}`),\n            };\n    }\n};\n","/**\n * @public\n */\nexport const hasAuthParams = (location = window.location): boolean => {\n    // response_mode: query\n    let searchParams = new URLSearchParams(location.search);\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    // response_mode: fragment\n    searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    return false;\n};\n\nconst normalizeErrorFn = (fallbackMessage: string) => (error: unknown): Error => {\n    if (error instanceof Error) {\n        return error;\n    }\n    return new Error(fallbackMessage);\n};\n\nexport const loginError = normalizeErrorFn(\"Login failed\");\n","import React from \"react\";\n\nimport { AuthContext, AuthContextProps } from \"./AuthContext\";\n\n/**\n * @public\n */\nexport const useAuth = (): AuthContextProps => {\n    const context = React.useContext(AuthContext);\n\n    if (!context) {\n        throw new Error(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n    }\n\n    return context;\n};\n","import React from \"react\";\n\nimport type { AuthContextProps } from \"./AuthContext\";\nimport { useAuth } from \"./useAuth\";\n\n/**\n * A public higher-order component to access the imperative API\n * @public\n */\nexport function withAuth<P>(\n    Component: React.ComponentType<P>,\n): React.ComponentType<Omit<P, keyof AuthContextProps>> {\n    const displayName = `withAuth(${Component.displayName || Component.name})`;\n    const C: React.FC<Omit<P, keyof AuthContextProps>> = (props) => {\n        const auth = useAuth();\n\n        return <Component {...(props as P)} auth={auth} />;\n    };\n\n    C.displayName = displayName;\n\n    return C;\n}\n"]},"metadata":{},"sourceType":"module"}